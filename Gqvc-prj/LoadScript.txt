///$tab Info 
// ***************	Generic Qlikview Components Library	*************** 
// ***************	Author: Syed Maqsood	*************** 
// ***************	First version Date: 19/09/2014	*************** 
// ***************	Last modified Date: 27/07/2015	*************** 
///$tab Change Log 
/* *********************** Change Log *********************** 
Versioning convention 
X.Y.Z ==>	X --> New functionality: when a new tab is created which enhances Gqvc's capabilities. 
			Y --> New sub-routines: when a new sub-routine is created to extend/improve existing components 
			Z --> Bug fixes 
*/ 

[Gqvc.Version]:
LOAD
	DATE#(SUBFIELD([Date||Version||Change Description],'||',1),'DD/MM/YYYY')	AS Gqvc.Date,
	TRIM(SUBFIELD([Date||Version||Change Description],'||',2))					AS	Gqvc.Version,
	TEXT(TRIM(SUBFIELD([Date||Version||Change Description],'||',3)))			AS	[Gqvc.Description]
;
LOAD * INLINE [
Date||Version||Change Description 
19/09/2014||1.0.0||First release of the Gqvc 
27/10/2014||1.0.1||Fixed "StoreDropAllTablesToQvd" to drop all tables. The loop was using TableName($(i)) instead of TableName(0) 
03/11/2014||1.1.0||Added new sub-routine "Gqvc.ResolvePath"  to check if directory exists 
19/11/2014||2.0.0||Added new sub-routines (tabs: Field Management and Calendar Management) to create a Generic Field and Calendar Management 
20/11/2014||3.0.0||Added new sub-routine "Gqvc.LogEvent" (tab: Log Management) to create event logs 
20/11/2014||3.0.1||Rectified logic to resolve UNC path. Added log events for errors in creating or deleting directories. Call to Gqvc.RaiseFatalError will now result in terminating script execution 
09/12/2014||3.0.2||Gqvc.ResolvePath can now handle trailing '\' in the directory path. E.g., if directory is 'H:\SubFolder\' will now resolve to 'H:\SubFolder' 
09/12/2014||3.0.3||Minor fix to Gqvc.ResolvePath, which now accepts all combinations of paths expect for '.\' when the current directory is the rootfolder 
10/12/2014||3.0.4||Minor fix to Gqvc.CreateDirectory to check successful directory creation for UNC path 
10/12/2014||3.0.5||Minor fix to Gqvc.DeleteDirectory to check successful directory deletion for UNC path 
12/12/2014||3.0.6||Minor fix to Gqvc.DeleteAllQvdFilesFromDirectory for UNC path 
17/12/2014||3.1.0||Added new Optional parameter "QVDName" to Gqvc.StoreDataQVD. This means QVDs can now be stored with names other than in-memory tablenames. Also, added new sub-routine "Gqvc.ReduceDataQvd" which helps to reduce QVD to a given number of records. 
18/12/2014||3.1.1||Fixed bug - Gqvc.DeleteDirectory left dummy file when it failed to delete a directory.  
03/01/2015||4.0.0||Created new tab "Script Macros". Added sub "Gqvc.GetFieldValues" in Field mgmt. "Gqvc.ReduceDataQvd" can now create sample of records.  
19/01/2015||4.0.1||Used *.* to resolve UNC path instead of having to create/delete '__Dummy_$@#.txt' 
21/01/2015||4.0.2||"Gqvc.Macro.v.CreateRandomName" produces relatively more unique numbers and reduces chances of name collision. Updated "GetFieldValues" & "ReduceDataQvd" to use macro definitions. 
18/06/2015||4.0.3||Fix for Gqvc.LogEvent to handle filename with spaces, Gqvc.ResolvePath to handle non-existing directories when called by CreateDirectory.
18/06/2015||4.0.3||Added Gqvc.CleanupMacros to cleanup routine and removed Gqvc.DeleteDirectory routine due to security risk
24/06/2015||4.0.4||Minor fix to Gqvc.CreateCalendarFromField routine, which was excluding last date record & enabled logging to file
09/07/2015||4.0.5||Bug fix on Gqvc.StoreDropAllTablesToQvd. Loop failed to pick correct tablenames when reserved "Gqvc" survived delete.
21/07/2015||4.1.0||Added Gqvc Configuration variables and improved Cleanup routines to remove Gqvc variables & tables in a controlled manner.
27/07/2015||4.2.0||Gqvc.RecursiveDirectory & Gqvc.RecursiveFile released for use
];

LET Gqvc.ChangeLog.v.Version = PEEK('Gqvc.Version',-1,'Gqvc.Version'); 
TRACE Gqvc Version: $(Gqvc.ChangeLog.v.Version); 
///$tab Gqvc Configuration
// *********************** Gqvc global configuration *********************** 

/* Gqvc.Config.v.SystemAccessMode settings
0 -> Qlikview default and does not require additional security settings
1 -> Creates files/folders; Requires Settings -> "Can Execute External Programs" 
2 -> Can create and delete files/folders; Requires Settings -> "Can Execute External Programs" 
*/
SET Gqvc.Config.v.SystemAccessMode = 1;

/* Gqvc.Config.v.LogMode settings
0 -> No log created 
1 -> Log file stored & read as data file. Log will not be created until script has successfully ran. 
2 -> Can create log files at run time; Requires Settings -> "Can Execute External Programs" 
*/ 
SET Gqvc.Config.v.LogMode = 0;

/* Gqvc.Config.v.LogMode settings for Gqvc.Cleanup
0 -> Deletes routines specific variables only
1 -> Deletes macros along with routine specific variables
2 -> Deletes all Gqvc variables except Gqvc.ChangeLog.v.Version 
*/ 
SET Gqvc.Config.v.CleanupVariables = 0;

/* Gqvc.Config.v.LogMode settings for Gqvc.Cleanup
Gqvc.CleanupTables defines a matrix and mode to be deleted. It is a custimizable matrix and can include tables added in future
*/ 
SET Gqvc.Config.v.CleanupTables = 5;

[Gqvc.CleanupTables]:
LOAD * INLINE [
    CleanupTables, Mode0, Mode1, Mode2, Mode3, Mode4, Mode5
    Gqvc.Version, 0, 1, 0, 0, 1, 1
    Gqvc.ClearVariables, 0, 0, 1, 0, 1, 0
    Gqvc.ScannedFileList, 0, 0, 0, 1, 1, 1
];
// *********************** Gqvc global configuration *********************** 
///$tab Script Macros 
// Macros  
// ****************************** Start Sub ****************************** 
/* 
Param 1 Positive Integer: Position of 1 in the binary string 
Param 2 Positve Integer: Binary string lenght 
Syntax $(Gqvc.Macro.v.CreateBitString(2,3)); 
*/ 
SET Gqvc.Macro.v.CreateBitString = If(Len(Trim($2))=0, Repeat(0,$1-1) & 1, Repeat(0,$1-1) & 1 & Repeat(0,$2-$1)); 

SET Gqvc.Macro.v.DefaultIfEmpty = If(Len(Trim($1))= 0, $2, $1); // Returns second argument if first argument is empty 
SET Gqvc.Macro.v.FieldExists = IF(Len(Trim($1))>0, IsNull(FieldValueCount($1)),-1); // Returns 0 if field exists else -1 
SET Gqvc.Macro.v.TableExists = IF(Len(Trim($1))>0, IsNull(TableNumber($1)),-1); // Returns 0 if table exists else -1 
SET Gqvc.Macro.v.FileExists = IF(Len(Trim($1))>0, IsNull(FileSize($1)),-1); 
SET Gqvc.Macro.v.IsReserved = WildMatch($1,'Gqvc.*','_Gqvc.*'); // Returns integer > 0 if table/field name contains "Gqvc" exists else 0 
SET Gqvc.Macro.v.CreateRandomName =  IF(Len(Trim($1))>0,$1 & '_','__Temp_') & Ceil(pow((Rand()+1)*10,Rand()+pi())); // Creates random name. Argument passed will be part of the name  
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Table to be called via VB macro in QVW 
// Use this code in VB macro script: ExecuteGlobal ActiveDocument.Evaluate("Concat(Gqvc.MacroCode, Chr(10), Gqvc.MacroLine)") 
[Gqvc.ClearVariables]: 
LOAD  
	Gqvc.MacroCode 
	,RowNo() as Gqvc.MacroLine 
INLINE [ 
    Gqvc.MacroCode 
	Sub ClearVariables() 
		Set vars = ActiveDocument.GetVariableDescriptions 
		For i = 0 to vars.Count - 1 
		    Set v = vars.Item(i) 
		    ActiveDocument.RemoveVariable v.Name 
		Next 
	End Sub 
]; 
// ****************************** End Sub ****************************** 
///$tab Table Management 
// Table Management - functions for managing Qlikview in-memory tables. 


// ****************************** Start Sub ****************************** 
/* 
Drops an in memory table, if it exists. 
@param 1 String. TableName: Name of the table to be dropped. 
@syntax CALL Gqvc.DropTable('TableName'); 
*/ 
SUB Gqvc.DropTable(TableName) 
	TRACE Gqvc.DropTable(TableName: [$(TableName)]); 
	 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = -1 THEN 
	    TRACE Table: [$(TableName)], does not exist. Table cannot be dropped.; 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(TableName)')) > 0 AND Len('$(Gqvc.Cleanup.v.Reserved)')=0  THEN 
		TRACE Table: [$(TableName)], is reserved. Table will not be dropped.;      
	ELSE 
	    DROP TABLE [$(TableName)]; 
	    TRACE Table dropped. [$(TableName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Field Management 
// Field Management - functions for managing Qlikview in-memory fields. 


// ****************************** Start Sub ****************************** 
/* 
Drops an in memory field, if it exists. 
@param 1 String. FieldName: Name of the field to be dropped. 
@syntax CALL Gqvc.DropField('FieldName'); 
*/ 
SUB Gqvc.DropField(FieldName) 
	TRACE Gqvc.DropField(FieldName: [$(FieldName)]); 
	 
	IF $(Gqvc.Macro.v.FieldExists('$(FieldName)')) = -1 THEN 
	    TRACE Field: [$(FieldName)], does not exist. Field cannot be dropped.; 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(FieldName)')) > 0 AND Len('$(Gqvc.Cleanup.v.Reserved)')=0  THEN 
		TRACE Field: [$(FieldName)], is reserved. Field will not be dropped.;	     
	ELSE 
	    DROP Field [$(FieldName)]; 
	    TRACE Field dropped. [$(FieldName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 




// ****************************** Start Sub ****************************** 
/** 
Get min & max values of a Field. The values are set in variables names using parameter 2 or fieldname as the prefix. For example, if parameter 2 is 'vStat', the set variables will be: 


	vStat.Min  =  the Min value of the field. 
	vStat.Max  =  the Max value of the field. 
     
@syntax Gqvc.GetFieldValues('LastUpdate', ['vStats'], ['Transactions.qvd']); 


@param 1 String. The field name. 
@param 2 String, Optional. Variable prefix name in which to return values. Variables created will prefix.Max, prefix.Min. 
@param 3 String, Optional. Source that contains the field. If Source ends with '.qvd', source is assumed to be a QVD. If not, Source is a RESIDENT table. If omitted, all values of field are the source. 
*/ 
SUB Gqvc.GetFieldValues(FieldName, ReturnVariable, SourceName) 


	IF Len(Trim('$(SourceName)')) = 0 THEN 
		SET _vSource = ";LOAD FieldValue('$(FieldName)', recno()) as [$(FieldName)] AUTOGENERATE FieldValueCount('$(FieldName)')"; 
	ELSEIF WildMatch('$(SourceName)', '*.???') = 0 THEN 
		SET _vSource = 'RESIDENT $(SourceName)'; 
	ELSEIF WildMatch('$(SourceName)', '*.qvd') > 0 THEN 
		SET _vSource = 'FROM [$(SourceName)] (qvd)'; 
//	ELSE // Can be used to assume text file as source 
//		SET _vSource = 'FROM $(SourceName)';	 
	ENDIF 
	 
	LET Gqvc.v.TempTableName = $(Gqvc.Macro.v.CreateRandomName('__Gqvc.GetFieldValues')); 
	 
	[$(Gqvc.v.TempTableName)]: 
	LOAD  
		Max([$(FieldName)]) as _maxval, 
		Min([$(FieldName)]) as _minval	 
	$(_vSource); 
	 
	LET v.Prefix = $(Gqvc.Macro.v.DefaultIfEmpty('$(ReturnVariable)','$(FieldName)')); 
	LET $(v.Prefix).Max = peek('_maxval'); 
	LET $(v.Prefix).Min = peek('_minval'); 


	DROP table [$(Gqvc.v.TempTableName)]; 


	SET Gqvc.v.TempTableName = ; 
	SET v.Prefix = ; 
	SET _vSource = ; 
END SUB 
// ****************************** End Sub ****************************** 
///$tab QVD Management 
// QVD Management - Functions for managing QVDs 


// ****************************** Start Sub ****************************** 
// Stores in memory table to QVD file. 
// Parameters: 
// @param 1 String. TableName: Name of the table to be written to QVD. 
// @param 2 String. QvdPath: Path of the QVD file to be written. 
// @param 3 String, Optional. QvdName: Name of the QVD file, to be saved, if different from the TableName. 
// @syntax CALL Gqvc.StoreDataQvd('TableName', 'QvdPath'); 
SUB Gqvc.StoreDataQvd(TableName, QvdPath, QvdName) 
	CALL Gqvc.CreateDirectory('$(QvdPath)');	 
	TRACE Gqvc.StoreDataQvd(TableName:[$(TableName)], QvdPath:[$(v.ResolvedDirectoryPath)]); 

	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = -1 THEN 
	    TRACE Table: [$(TableName)], does not exist. Table cannot be stored.;		 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(TableName)')) > 0 THEN 
		TRACE Table: [$(TableName)], is a reserved table. Table will not be stored.;		 
	ELSE 
		LET Gqvc.Qvd.v.QvdFileName = $(Gqvc.Macro.v.DefaultIfEmpty('$(QvdName)','$(TableName)'));	//IF(LEN(TRIM('$(QvdName)')) > 0,'$(QvdName)','$(TableName)'); 
		STORE [$(TableName)] INTO [$(v.ResolvedDirectoryPath)\$(Gqvc.Qvd.v.QvdFileName).qvd] (qvd); 
		TRACE TableName:[$(TableName)] stored at QvdPath:[$(v.ResolvedDirectoryPath)]; 
	END IF 
	 
	// Cleanup.. 
	LET Gqvc.Qvd.v.QvdFileName = ; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores in memory table to QVD file.  Drops in memory table after persisting to QVD. 
// Parameters: 
// @param 1 String. TableName: Name of the table to be written to QVD. 
// @param 2 String. QvdPath: Path of the QVD file to be written. 
// @param 3 String, Optional. QvdName: Name of the QVD file, to be saved, if different from the TableName. 
// @syntax CALL Gqvc.StoreDropDataQvd('TableName', 'QvdPath'); 
SUB Gqvc.StoreDropDataQvd(TableName, QvdPath, QvdName) 
	TRACE Gqvc.StoreDropDataQvd(TableName:[$(TableName)], QvdPath:[$(QvdPath)]); 
    CALL Gqvc.StoreDataQvd('$(TableName)','$(QvdPath)','$(QvdName)'); 
    CALL Gqvc.DropTable('$(TableName)'); 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores all in memory tables to QVD. 
// Parameters: 
// @param 1 String. QvdDirectory: root folder for Qvd storage. 
// @syntax CALL Gqvc.StoreAllTablesToQvd('QvdDirectory'); 
SUB Gqvc.StoreAllTablesToQvd(QvdDirectory) 
        TRACE StoreAllTablesToQvd(QvdDirectory:[$(QvdDirectory)]); 
		 
        FOR i = 0 TO NoOfTables()-1
        	LET Gqvc.v.QVD.TableName	=	TableName(i); 
			CALL Gqvc.StoreDataQvd('$(Gqvc.v.QVD.TableName)',QvdDirectory); 
        NEXT 
      
     // Cleanup.. 
     SET i=;  
     SET Gqvc.v.QVD.TableName=;
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores all in memory tables to QVD and drops the tables. 
// Parameters: 
// @param 1 String. QvdDirectory: root folder for Qvd storage. 
// @syntax CALL Gqvc.StoreDropAllTablesToQvd('QvdDirectory'); 
SUB Gqvc.StoreDropAllTablesToQvd(QvdDirectory) 
        TRACE StoreDropAllTablesToQvd(QvdDirectory:[$(QvdDirectory)]); 
		 
        FOR i = 0 TO NoOfTables()-1
			[Gqvc.TablesToDrop]:
			LOAD
				TABLENAME($(i))	AS Gqvc.TableNameToDrop
			AUTOGENERATE 1;
        NEXT 
		FOR i=0 TO NoOfRows('Gqvc.TablesToDrop')-1
        	LET Gqvc.v.QVD.TableName	=	PEEK('Gqvc.TableNameToDrop',$(i),'Gqvc.TablesToDrop');
        	CALL Gqvc.StoreDropDataQvd('$(Gqvc.v.QVD.TableName)',QvdDirectory);  
		NEXT

	// Drop table
	DROP TABLE [Gqvc.TablesToDrop];
     // Cleanup..
     SET i=; 
     SET Gqvc.v.QVD.TableName=; 
END SUB 
// ****************************** End Sub ****************************** 




// ****************************** Start Sub ****************************** 
/* 
Removes all *.qvd files from a directory (and sub directories if parameter is IncludeSubDirectories is set to True() or a none zero value). 


@param 1 String. DirectoryPath: The path of the directory. 
@param 2 Boolean, Optional. IncludeSubDirectories: Delete files from all subdirectories too.  Default is false. 


@syntax CALL Gqvc.DeleteAllQvdFilesFromDirectory('DirectoryPath', ['IncludeSubDirectories']); 
*/ 
SUB Gqvc.DeleteAllQvdFilesFromDirectory(DirectoryPath, IncludeSubDirectories) 
	IF Gqvc.Config.v.SystemAccessMode <> 2 THEN
		TRACE Insufficient permissions! Security settings does not allow QVD delete operation;
		CALL Gqvc.LogEvent('Insufficient permissions! Security settings does not allow QVD delete operation','E');
	ELSE	
		TRACE DeleteAllQvdFilesFromDirectory(DirectoryPath:[$(DirectoryPath)]) 
			IncludeSubDirectories:[$(IncludeSubDirectories)] ; 
			 
		LET _IncludeSubDirectories = $(Gqvc.Macro.v.DefaultIfEmpty('$(IncludeSubDirectories)',0)); //if(len('$(IncludeSubDirectories)')>0,1,0); 
	
		CALL Gqvc.ResolvePath('$(DirectoryPath)'); 
	
		IF Gqvc.Config.v.SystemAccessMode <> 2 THEN
			TRACE Insufficient privilege. No QVDs will be deleted from Directory [$(DirectoryPath)];
			CALL Gqvc.LogEvent('Insufficient privilege. No QVDs will be deleted from Directory [$(DirectoryPath)]','E');
		ELSEIF FileTime('$(v.ResolvedDirectoryPath)\*.*') > 0 THEN 
			 IF(_IncludeSubDirectories) THEN 
				TRACE Deleting ALL QVDs from Directory $(DirectoryPath) and ALL sub directories; 
				EXECUTE cmd /C DEL /S "$(v.ResolvedDirectoryPath)\*.qvd"; 
			 ELSE 
				  TRACE Deleting ALL QVDs from Directory $(DirectoryPath); 
				  EXECUTE cmd /C DEL "$(v.ResolvedDirectoryPath)\*.qvd"; 
			 END IF 
		ELSE 
				TRACE Directory does not exist $(DirectoryPath); 
		END IF 
	END IF
	SET _IncludeSubDirectories=; // Reset 
END SUB 
// ****************************** End Sub ****************************** 




// ****************************** Start Sub ****************************** 
// Reduces data from a QVD file to number of record passed as argument.  
// Parameters: 
// @param 1 String. QvdName: Name of the QVD. No ".qvd" extension required in the name. 
// @param 2 String. QvdPath: Path of the QVD file.  
// @param 3 Number, Optional. Number of records to retain in the QVD after reduce. If no value is entered, all data will be removed. Values between 0 and 1 will retain sample records. 
// @syntax CALL Gqvc.ReduceDataQvd('QvdName', 'QvdPath',RecordsToRetain); 
// @E.g., CALL Gqvc.ReduceDataQvd('Sales Data', '..\Data\Sales',100000); 
SUB Gqvc.ReduceDataQvd(QvdName, QvdPath, RecordsToRetain) 


	CALL Gqvc.ResolvePath('$(QvdPath)'); 
	LET Gqvc.Qvd.v.QvdFileName = '$(v.ResolvedDirectoryPath)\$(QvdName).qvd' ; 
	LET Gqvc.Qvd.v.RecordsToRetain = IF(LEN(TRIM('$(RecordsToRetain)'))	= 0, 0, IF(ISNUM('$(RecordsToRetain)')=-1,$(RecordsToRetain),-1)); 
	TRACE Gqvc.ReduceDataQvd(QvdName:[$(QvdName)], QvdPath:[$(v.ResolvedDirectoryPath)], RecordsToRetain: [$(RecordsToRetain)]); 


	IF FileTime('$(Gqvc.Qvd.v.QvdFileName)') > 0 THEN 
		LET Gqvc.Qvd.v.QvdNoOfRecords.Original = QvdNoOfRecords('$(Gqvc.Qvd.v.QvdFileName)'); 
		LET Gqvc.Qvd.v.TempTableName = $(Gqvc.Macro.v.CreateRandomName('__Gqvc.ReduceDataQvd')); //'__Dummy_$@#'; 


		IF $(Gqvc.Qvd.v.RecordsToRetain) > $(Gqvc.Qvd.v.QvdNoOfRecords.Original) THEN 
			TRACE QvdName:[$(QvdName)] already has fewer records [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] than given limit [$(RecordsToRetain)]. No reduction of data will happen; 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) > 0 AND $(Gqvc.Qvd.v.RecordsToRetain) < 1 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			SAMPLE $(Gqvc.Qvd.v.RecordsToRetain) 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd) 
			WHERE 1=1; 
	 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(v.ResolvedDirectoryPath)', '$(QvdName)'); 
			TRACE QvdName:[$(v.ResolvedDirectoryPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] and a sample of [$(RecordsToRetain)] records are retained; 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) > 0 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			FIRST $(Gqvc.Qvd.v.RecordsToRetain) 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd); 
	 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(v.ResolvedDirectoryPath)', '$(QvdName)'); 
			TRACE QvdName:[$(v.ResolvedDirectoryPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] to [$(RecordsToRetain)] records; 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) = 0 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			FIRST 1 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd); 
				INNER JOIN ($(Gqvc.Qvd.v.TempTableName)) 
			LOAD * RESIDENT [$(Gqvc.Qvd.v.TempTableName)] WHERE 1=2; 
			 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(v.ResolvedDirectoryPath)', '$(QvdName)'); 
			TRACE QvdName:[$(v.ResolvedDirectoryPath)\$(QvdName)] fully truncated from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] records;			 
		 
		ELSE 
			TRACE 'Invalid argument value for RecordsToRetain. Only positive integers are allowed'; 
			CALL Gqvc.LogEvent('Invalid argument value for RecordsToRetain. Only positive integers are allowed','E'); 
		END IF 


	ELSE 
	    TRACE Qvd:[$(QvdName)], does not exist at QvdPath:[$(v.ResolvedDirectoryPath)]. QVD cannot be reduced.;	 
		CALL Gqvc.LogEvent('Qvd:[$(QvdName)], does not exist at QvdPath:[$(v.ResolvedDirectoryPath)]. QVD cannot be reduced.','E');	 
	END IF 


	// Cleanup.. 
	LET Gqvc.Qvd.v.RecordsToRetain =;  
	LET Gqvc.Qvd.v.QvdFileName = ; 
	LET Gqvc.Qvd.v.QvdNoOfRecords.Original = ; 
	LET Gqvc.Qvd.v.TempTableName = ; 
	 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Directory Management 
// Directory Management - Functions for managing file system 


// ****************************** Start Sub ****************************** 
/* 
Creates a directory on the file system if it does not already exist. 


@param 1 String. DirectoryPath: The path of the directory. 
@syntax CALL Gqvc.CreateDirectory('DirectoryPath'); 
*/ 

SUB Gqvc.CreateDirectory(DirectoryPath) 
	SET v.NonExistingDirAllowed = -1; // To allow Gqvc.ResolvePath to return non-existing directory path
	CALL Gqvc.ResolvePath('$(DirectoryPath)'); 
	TRACE Gqvc.CreateDirectory(DirectoryPath:[$(v.ResolvedDirectoryPath)]); 
	 
	IF FileTime('$(v.ResolvedDirectoryPath)\*.*') > 0 THEN 
		TRACE Directory Exists $(v.ResolvedDirectoryPath);
	ELSEIF Gqvc.Config.v.SystemAccessMode = 0 THEN
		TRACE Insufficient privilege. Directory [$(v.ResolvedDirectoryPath)] cannot be created;
		CALL Gqvc.LogEvent('Insufficient privilege. Directory [$(v.ResolvedDirectoryPath)] cannot be created','E');   
	ELSE 
	    TRACE Creating Directory $(v.ResolvedDirectoryPath); 
	    EXECUTE cmd /C mkdir "$(v.ResolvedDirectoryPath)";  

		IF IsNull(FileTime('$(v.ResolvedDirectoryPath)\*.*'))  THEN 
			TRACE Error creating directory: $(v.ResolvedDirectoryPath); 
			CALL Gqvc.LogEvent('Error creating directory: $(v.ResolvedDirectoryPath)','E'); 
			CALL Gqvc.RaiseFatalError; 
	    END IF     
	END IF
	
	SET v.NonExistingDirAllowed =; // Reset
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Resolves relative path in absolute path 


@param 1 String. DirectoryPath: The path of the directory. 
@syntax CALL Gqvc.ResolvePath('DirectoryPath'); 
*/ 
SUB Gqvc.ResolvePath(ResolveDirectoryPath) 
	LET v.Path = Replace(DocumentPath(),'\'&DocumentName(),''); 


	// Remove any trailing '\' from the resolved directory path 
	IF	WildMatch('|'&'$(ResolveDirectoryPath)'&'|','|.\|', '|..\|', '|.\*\|', '|..\*\|', '|\\*\|','|*\|') >= 3 THEN 
		LET ResolveDirectoryPath = Left('$(ResolveDirectoryPath)',Len('$(ResolveDirectoryPath)')-1); 
	END IF			 


	IF FileTime('$(ResolveDirectoryPath)') > 0 THEN 
		LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
	 
	ELSEIF SubStringCount('$(ResolveDirectoryPath)','.\') > 0 THEN // for relaive path 
		IF SubStringCount('\' & '$(ResolveDirectoryPath)' & '\','\.\\') > 0 THEN 
			LET v.ResolvedDirectoryPath = '$(v.Path)'; 
		ELSEIF 	SubStringCount('\' & '$(ResolveDirectoryPath)' & '\','\.\') > 0 THEN 
			LET v.ResolvedDirectoryPath = '$(v.Path)' & '\' & Replace('$(ResolveDirectoryPath)','.\',''); 
		ELSE 
			LET v.NodeCount = SubStringCount('$(ResolveDirectoryPath)','..\'); 
			LET v.FixedPath = Mid('$(ResolveDirectoryPath)',Index('$(ResolveDirectoryPath)','..\',$(v.NodeCount))+3); 
			LET v.ResolvedRelativePath = Left('$(v.Path)',Index('$(v.Path)','\',$(v.NodeCount)*-1)-1); 
			LET v.ResolvedDirectoryPath = '$(v.ResolvedRelativePath)' & If(Len('$(v.FixedPath)')>0,'\'&'$(v.FixedPath)',Null());		 
		END IF	 


	ELSEIF	Left('$(ResolveDirectoryPath)',2) = '\\' THEN // for UNC path 
		IF Right('$(ResolveDirectoryPath)',1) = '\' THEN 
			LET v.ResolvedDirectoryPath = LEFT('$(ResolveDirectoryPath)',LEN('$(ResolveDirectoryPath)')-1); 
		ELSE 
			LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
		END IF 
		 
	ELSEIF v.NonExistingDirAllowed=-1 THEN
		LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)';
		CALL Gqvc.LogEvent('Permitted by not existing directory override: $(ResolveDirectoryPath)','I');
		
	ELSE 
		TRACE Cannot resolve document path: '$(ResolveDirectoryPath)'; 
		CALL Gqvc.LogEvent('Cannot resolve document path: $(ResolveDirectoryPath)','E');  
		CALL Gqvc.RaiseFatalError;	 
	END IF 


	// Cleanup.. 
	SET v.Path = ; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Recursive through directory path

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 Numeric, default is 0. IncludeSubfolder: 0 -> to scan current directory only, 1 -> to scan all subdirectories
@param 3 String. LoopBack: Name of the subroutine to be called for each directory scan
@param 4 String. LoopBackParm: Argument to be included in a Loopback call
@param 5 Numeric. ParmOverride: Overrides, how and what argument you want to pass to Loop back call
	0 -> To pass only directory path as an argument to calling sub routine or Loop back
	1 -> To pass only LoopBackParm as an argument to calling sub routine or Loop back
	2 -> To pass both directory path and LoopBackParm as an argument to calling sub routine or Loop back
	default -> If Loopback parameter is present, send both directory and LoopBackParm othewise send only Directory
@syntax CALL Gqvc.RecursiveDirectory('.\',1,'Gqvc.LogEvent','Repeats log message for each directory scanned',2); 
*/ 
// Initialise
LET Gqvc.Rcrv.v.Mask =;
LET Gqvc.Rcrv.v.IncludeSubFolder =;
LET Gqvc.Rcrv.v.LoopBackParm =;
LET Gqvc.Rcrv.v.ParmOverride =;
LET Gqvc.Rcrv.v.LoopBack =;
LET Gqvc.Rcrv.v.Callback =;
SUB Gqvc.RecursiveDirectory(DirectoryPath,IncludeSubfolder,LoopBack,LoopBackParm,ParmOverride)
	CALL Gqvc.ResolvePath(DirectoryPath); 
	LET Gqvc.Rcrv.v.Mask = IF(RIGHT('$(v.ResolvedDirectoryPath)',1) = '\','*','\*');
	LET Gqvc.Rcrv.v.IncludeSubFolder = $(Gqvc.Macro.v.DefaultIfEmpty('$(IncludeSubfolder)',0));
	LET Gqvc.Rcrv.v.LoopBackParm = $(Gqvc.Macro.v.DefaultIfEmpty('$(LoopBackParm)',''));
	LET Gqvc.Rcrv.v.ParmOverride = $(Gqvc.Macro.v.DefaultIfEmpty('$(ParmOverride)',-1));    
	LET Gqvc.Rcrv.v.LoopBack = $(Gqvc.Macro.v.DefaultIfEmpty('$(LoopBack)',''));
	
	IF Gqvc.Rcrv.v.IncludeSubFolder = 1 THEN
		FOR Each Dir in dirlist (v.ResolvedDirectoryPath & '$(Gqvc.Rcrv.v.Mask)' )
			LET Gqvc.Rcrv.v.Callback = IF(LEN(TRIM('$(Gqvc.Rcrv.v.LoopBack)'))>0,'CALL $(Gqvc.Rcrv.v.LoopBack)' & CHR(40) & CHR(39) & 
										IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))=0) OR $(Gqvc.Rcrv.v.ParmOverride)=0,'$(Dir)',
											IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))<>0) OR $(Gqvc.Rcrv.v.ParmOverride)=2,'$(Dir)' & CHR(39) & CHR(44) & CHR(39) & '$(Gqvc.Rcrv.v.LoopBackParm)',
												IF($(Gqvc.Rcrv.v.ParmOverride)=1, '$(Gqvc.Rcrv.v.LoopBackParm)'))) & CHR(39) & CHR(41),'');				
			TRACE Directory is [$(Dir)], Callback request [$(Gqvc.Rcrv.v.Callback)];
			$(Gqvc.Rcrv.v.Callback);
			CALL Gqvc.RecursiveDirectory('$(Dir)',$(Gqvc.Rcrv.v.IncludeSubFolder),'$(Gqvc.Rcrv.v.LoopBack)','$(Gqvc.Rcrv.v.LoopBackParm)',$(Gqvc.Rcrv.v.ParmOverride)); 
		NEXT Dir
	ELSE
			LET Gqvc.Rcrv.v.Callback = IF(LEN(TRIM('$(Gqvc.Rcrv.v.LoopBack)'))>0,'CALL $(Gqvc.Rcrv.v.LoopBack)' & CHR(40) & CHR(39) & 
										IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))=0) OR $(Gqvc.Rcrv.v.ParmOverride)=0,'$(v.ResolvedDirectoryPath)',
											IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))<>0) OR $(Gqvc.Rcrv.v.ParmOverride)=2,'$(v.ResolvedDirectoryPath)' & CHR(39) & CHR(44) & CHR(39) & '$(Gqvc.Rcrv.v.LoopBackParm)',
												IF($(Gqvc.Rcrv.v.ParmOverride)=1, '$(Gqvc.Rcrv.v.LoopBackParm)'))) & CHR(39) & CHR(41),'');
			
		TRACE Directory is [$(v.ResolvedDirectoryPath)], Callback request [$(Gqvc.Rcrv.v.Callback)];
		$(Gqvc.Rcrv.v.Callback);
	END IF
	
	// Cleanup
	LET Gqvc.Rcrv.v.Callback =;	
END SUB 

/* 
Scan for files in a directory

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 String. FileExtension: File extension that needs to be scanned.
@syntax CALL Gqvc.RecursiveFile('.\','xls'); 
*/ 
SUB Gqvc.RecursiveFile(DirectoryPath, FileExtension)
	FOR Each File IN FILELIST(DirectoryPath &'\*.' & FileExtension)
		[Gqvc.ScannedFileList]:
		LOAD 
			'$(File)' as Gqvc.FileName, 
			FileSize( '$(File)' ) as Gqvc.FileSize, 
			FileTime( '$(File)' ) as Gqvc.FileTime
		AUTOGENERATE 1;
	NEXT File	
END SUB
// ****************************** End Sub ****************************** 
///$tab Error Management 
// Error Management - Functions for errors 


// ****************************** Start Sub ****************************** 
/* 
Create fatal error to stop execution of script 
@syntax CALL Gqvc.RaiseFatalError; 
*/ 


SUB Gqvc.RaiseFatalError 
	TRACE Fatal error raised!!; 
	CALL Gqvc.LogEvent('Fatal error raised! Script execution will stop','E'); 
	CALL Gqvc.Cleanup;
	SET ErrorMode = 1; // To force erroring out, even if Error mode is set to 0 by the user. 
	CALL FatalError; // Dummy sub to create script error 
	EXIT Script; 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Log Management 
// Log Management - Functions for creating and maintaining document specific logs 


// ****************************** Start Sub ****************************** 
/* 
Creates a log file and writes event instantly. If a log file does not exists, it creates one, otherwise it appends to the log file. 


@param 1 String. Log message 
@param 2 String, Optional. Log level. Acceptable values 'E', 'I' and 'W' (case insensitive) for Error, Information and Warning respectively. Default is Information. 
@syntax CALL Gqvc.LogEvent('LogMessage',['LogLevel']); 
*/ 
SET Gqvc.Log.v.NewRun = ; // Resets for each run 
SUB Gqvc.LogEvent(LogMessage,LogLevel) 


	IF LEN(LogLevel) > 0 THEN 
		LET Gqvc.Log.v.LogLevel = IF(UPPER(LEFT(LogLevel,1)) = 'W','Warning',IF(UPPER(LEFT(LogLevel,1)) = 'E','Error','Information')); 
	ELSE 
		LET Gqvc.Log.v.LogLevel = 'Information';	 
	END IF 
	 
	LET Gqvc.Log.v.LogFileName = TEXT(REPLACE(DOCUMENTNAME(),SUBFIELD(DOCUMENTNAME(),'.',-1),'log'));  //TEXT(DOCUMENTNAME() & '.log'); 
	LET Gqvc.Log.v.LogExists = IF(FILETIME(REPLACE(DOCUMENTPATH(),DOCUMENTNAME(),'')&'$(Gqvc.Log.v.LogFileName)') > 0,-1,0); 
		 
	LET Gqvc.Log.v.SingleRedirection = CHR(62); 
	LET Gqvc.Log.v.DoubleRedirection = CHR(62)&CHR(62); 
	LET Gqvc.Log.v.Delimiter = CHR(9); // 9 = Horizontal tab 
	 
	LET Gqvc.Log.v.LogMessage = TIMESTAMP(NOW()) & '$(Gqvc.Log.v.Delimiter)' & '$(Gqvc.Log.v.LogLevel)' & '$(Gqvc.Log.v.Delimiter)' & OSUser() & '$(Gqvc.Log.v.Delimiter)' & '$(LogMessage)'; 
	LET Gqvc.Log.v.NewLoadText = TIMESTAMP(NOW()) & '$(Gqvc.Log.v.Delimiter)' & 'Information' & '$(Gqvc.Log.v.Delimiter)' & OSUser() & '$(Gqvc.Log.v.Delimiter)' & '===== New Load ====='; 


	TRACE Gqvc.LogEvent(LogMessage:[$(LogMessage)], LogLevel:[$(Gqvc.Log.v.LogLevel)]); 
	IF Gqvc.Log.v.LogExists = -1 THEN 
		IF Len('$(Gqvc.Log.v.NewRun)')=0 THEN 	// check if this is a new run.  
			EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";					 
			SET Gqvc.Log.v.NewRun = 0; 
		END IF 
		EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogMessage) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";		 
	ELSE 
			EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.SingleRedirection) "$(Gqvc.Log.v.LogFileName)";					 
			SET Gqvc.Log.v.NewRun = 0; 
			EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogMessage) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)"; 
	END IF 


	// Cleanup.. 
	SET	Gqvc.Log.v.LogExists = ; 
	SET Gqvc.Log.v.LogFileName = ; 
	SET Gqvc.Log.v.SingleRedirection = ; 
	SET Gqvc.Log.v.DoubleRedirection = ; 
	SET Gqvc.Log.v.LogMessage = ; 
	SET Gqvc.Log.v.LogLevel = ; 
	SET Gqvc.Log.v.NewLoadText = ;  
	SET Gqvc.Log.v.Delimiter = ; 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Calendar Management 
// Calendar Management - Functions for creating and maintaining generic calendars 


// ****************************** Start Sub ****************************** 
/* 
Builds a generic calendar based on an existing date field, in the data model. 


@param 1 String. Existing date field Name 
@param 2 String. New calendar table name 
@param 3 String, Optional. Calendar field name prefix 


@syntax CALL Gqvc.CreateCalendarFromField('FieldName', 'NewTableName',['FieldPrefix']); 
*/ 
SUB Gqvc.CreateCalendarFromField(FieldName,TableName,FieldPrefix)
 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 THEN 
	    TRACE Table: [$(TableName)], already exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Table: [$(TableName)], already exist. Calendar table cannot be created','E');
	ELSEIF $(Gqvc.Macro.v.FieldExists('$(FieldName)')) = -1 THEN 
	    TRACE Date Field: [$(FieldName)], does not exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Date Field: [$(FieldName)], does not exist. Calendar table cannot be created','E'); 		 
	ELSE 
		[$(TableName)]:	  
		LOAD 
			[_Date]					AS [$(FieldName)],		// Link on Field Name 
			[_Date]					AS [%$(FieldName)],		// Link on %field name 
			YEAR(_Date)				AS [$(FieldPrefix)Year], 
			MONTH(_Date)			AS [$(FieldPrefix)Month], 
			DAY(_Date)				AS [$(FieldPrefix)Day],	 
			WEEK(_Date)				AS [$(FieldPrefix)Week], 
			WEEKDAY(_Date)			AS [$(FieldPrefix)Day Name],	 
			MONTHNAME(_Date)		AS [$(FieldPrefix)Month Year], 
			QUARTERNAME(_Date)		AS [$(FieldPrefix)Quarter Name], 
			'Q' & CEIL(MONTH(_Date)/3)		AS [$(FieldPrefix)Quarter] 
		;			 
		LOAD 
			DATE(_MinDate + IterNo()) AS _Date 
		WHILE 
			_MinDate + IterNo() <= _MaxDate + 1
		;		 
		LOAD 
			MIN(_DateField)-1 AS _MinDate, 
			MAX(_DateField) AS _MaxDate 
		;		 
		LOAD 
			FieldValue('$(FieldName)',RecNo()) AS _DateField 
		AUTOGENERATE 
			FieldValueCount('$(FieldName)');	 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Builds a generic calendar based on a start and end date values. 


@param 1 String. New calendar table name 
@param 2 Number. Calendar start date in numeric format 
@param 3 Number. Calendar end date in numeric format 
@param 4 String, Optional. Calendar field name prefix 


@syntax CALL Gqvc.CreateCalendar('NewTableName','','',['FieldPrefix']); 
*/ 


SUB Gqvc.CreateCalendar(TableName,StartDate,EndDate,FieldPrefix) 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 THEN 
	    TRACE Table: [$(TableName)], already exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Table: [$(TableName)], already exist. Calendar table cannot be created','E');		 
	ELSEIF $(StartDate) > $(EndDate) THEN 
		TRACE Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created;
		CALL Gqvc.LogEvent('Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created','E');	 
	ELSE	 
		[$(TableName)]:	  
		LOAD 
			[_Date]					AS [$(FieldPrefix)Date],		// Link on Field Name 
			NUM([_Date])			AS [%$(FieldPrefix)Date],		// Link on %field name 
			YEAR(_Date)				AS [$(FieldPrefix)Year], 
			MONTH(_Date)			AS [$(FieldPrefix)Month], 
			DAY(_Date)				AS [$(FieldPrefix)Day],	 
			WEEK(_Date)				AS [$(FieldPrefix)Week], 
			WEEKDAY(_Date)			AS [$(FieldPrefix)Day Name],	 
			MONTHNAME(_Date)		AS [$(FieldPrefix)Month Year], 
			QUARTERNAME(_Date)		AS [$(FieldPrefix)Quarter Name], 
			'Q' & CEIL(MONTH(_Date)/3)		AS [$(FieldPrefix)Quarter] 
		;	  
		LOAD 
			DATE(_MinDate + IterNo()) AS _Date 
		WHILE 
			_MinDate + IterNo() <= _MaxDate 
		;		 
		LOAD 
			$(StartDate)-1 AS _MinDate, 
			$(EndDate) AS _MaxDate 
		AUTOGENERATE (1);	 
		; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 
///$tab DB Management 
// ****************************** Start Sub ****************************** 
SUB Gqvc.GetTimestampFromSqlDB(ReturnDBTimestamp) 
/* 
Retrieves the current timestamp from the DB.   
@syntax CALL Gqvc.GetTimestampFromSqlDB; 
*/	
	TempTimestampFromDB: 
	REPLACE LOAD *; 
	SQL SELECT GETDATE() AS CurrentTimestampFromDB; 
	 
	LET ReturnDBTimestamp = TIMESTAMP(FieldValue('CurrentTimestampFromDB',1)); 


	TRACE Gqvc.GetTimestampFromSqlDB:[$(ReturnDBTimestamp)]; 
	CALL Gqvc.DropTable('TempTimestampFromDB'); 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
SUB Gqvc.GetTimestampFromOracleDB(ReturnDBTimestamp) 
/* 
Retrieves the current timestamp from the DB. 
@syntax CALL Gqvc.GetTimestampFromOracleDB; 
*/	 
	TempTimestampFromDB: 
	REPLACE LOAD *; 
	SQL SELECT SYSDATE "CurrentTimestampFromDB" FROM DUAL; 
	 
	LET ReturnDBTimestamp = TIMESTAMP(FieldValue('CurrentTimestampFromDB',1)); 


	TRACE Gqvc.GetTimestampFromOracleDB:[$(ReturnDBTimestamp)]; 
	CALL Gqvc.DropTable('TempTimestampFromDB'); 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Cleanup 
// Cleanup Gqvc created temporary variables, fields and tables 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.Cleanup; 
*/ 

SUB Gqvc.Cleanup
	CALL Gqvc.CleanupReservedTables 
	CALL Gqvc.CleanupVariables 
	CALL Gqvc.CleanupMacros
	CALL Gqvc.CleanupReservedVariables	 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Cleanup Variables 
@syntax CALL Gqvc.CleanupVariables; 
*/ 
SUB Gqvc.CleanupVariables 
	// Directory 
	LET v.ResolvedDirectoryPath =; 
	LET v.NodeCount =; 
	LET v.FixedPath =; 
	LET v.ResolvedRelativePath =; 

	// Log	 
	LET Gqvc.Log.v.NewRun =; 
	 
	// DB 
	LET ReturnDBTimestamp =;
	
	// Recursive routines
	LET Gqvc.Rcrv.v.Mask =;
	LET Gqvc.Rcrv.v.IncludeSubFolder =;
	LET Gqvc.Rcrv.v.LoopBackParm =;
	LET Gqvc.Rcrv.v.ParmOverride =;
	LET Gqvc.Rcrv.v.LoopBack =;
	LET Gqvc.Rcrv.v.Callback =;
	
	LET DirectoryPath =;
	LET IncludeSubfolder =;
	LET LoopBack =;
	LET LoopBackParm =;
	LET ParmOverride =;
	LET Dir =;
	LET FileExtension =;
	LET File =;
	 	
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupMacros; 
*/ 

SUB Gqvc.CleanupMacros 
	LET Gqvc.Macro.v.CreateBitString =; 
	LET Gqvc.Macro.v.CreateRandomName =; 
	LET Gqvc.Macro.v.DefaultIfEmpty =; 
	LET Gqvc.Macro.v.FieldExists =; 	 
	LET Gqvc.Macro.v.FileExists =;
	LET Gqvc.Macro.v.IsReserved =;
	LET Gqvc.Macro.v.TableExists =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupReservedVariables; 
*/ 

SUB Gqvc.CleanupReservedVariables 
	// Gqvc Configuration
	SET Gqvc.Config.v.SystemAccessMode =;
	SET Gqvc.Config.v.LogMode =;
	SET Gqvc.Config.v.CleanupVariables =;
	SET Gqvc.Config.v.CleanupTables =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupReservedTables; 
*/ 

SUB Gqvc.CleanupReservedTables 	
	LET Gqvc.Cleanup.v.Mode = 'Mode'&$(Gqvc.Config.v.CleanupTables);
	
	[Gqvc.CleanupReservedTables]:
	LOAD CleanupTables RESIDENT	Gqvc.CleanupTables WHERE $(Gqvc.Cleanup.v.Mode) = 1;
	
	SET Gqvc.Cleanup.v.Reserved = 1;
	IF NOOFROWS('Gqvc.CleanupReservedTables') > 0 THEN
		FOR i=0 TO NOOFROWS('Gqvc.CleanupReservedTables') - 1
			LET Gqvc.Cleanup.v.TableName = PEEK('CleanupTables',$(i),'Gqvc.CleanupReservedTables');
			CALL Gqvc.DropTable('$(Gqvc.Cleanup.v.TableName)');
		NEXT
	END IF
	
	// Cleanup
	CALL Gqvc.DropTable('Gqvc.CleanupTables');
	CALL Gqvc.DropTable('Gqvc.CleanupReservedTables');
	
	SET i=;
	SET Gqvc.Cleanup.v.Reserved =;
	SET Gqvc.Cleanup.v.Mode =;
	SET Gqvc.Cleanup.v.TableName =;	
END SUB 
// ****************************** End Sub ****************************** 
