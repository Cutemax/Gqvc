///$tab Info 
// ***************	Generic Qlikview Components Library	*************** 
// ***************	Author: Syed Maqsood	*************** 
// ***************	First version Date: 19/09/2014	*************** 
// ***************	Last modified Date: 04/11/2015	*************** 
///$tab Change Log 
/* *********************** Change Log *********************** 
Versioning convention 
X.Y.Z ==>	X --> New functionality: when a new tab is created which enhances Gqvc's capabilities. 
			Y --> New sub-routines: when a new sub-routine is created to extend/improve existing components 
			Z --> Bug fixes 
*/ 

[Gqvc.Version]:
LOAD
	DATE#(SUBFIELD([Date||Version||Change Description],'||',1),'DD/MM/YYYY')	AS	Gqvc.Date,
	TRIM(SUBFIELD([Date||Version||Change Description],'||',2))					AS	Gqvc.Version,
	TEXT(TRIM(SUBFIELD([Date||Version||Change Description],'||',3)))			AS	Gqvc.Description
;
LOAD * INLINE [
Date||Version||Change Description 
19/09/2014||1.0.0||First release of the Gqvc 
27/10/2014||1.0.1||Fixed "StoreDropAllTablesToQvd" to drop all tables. The loop was using TableName($(i)) instead of TableName(0) 
03/11/2014||1.1.0||Added new sub-routine "Gqvc.ResolvePath"  to check if directory exists 
19/11/2014||2.0.0||Added new sub-routines (tabs: Field Management and Calendar Management) to create a Generic Field and Calendar Management 
20/11/2014||3.0.0||Added new sub-routine "Gqvc.LogEvent" (tab: Log Management) to create event logs 
20/11/2014||3.0.1||Rectified logic to resolve UNC path. Added log events for errors in creating or deleting directories. Call to Gqvc.RaiseFatalError will now result in terminating script execution 
09/12/2014||3.0.2||Gqvc.ResolvePath can now handle trailing '\' in the directory path. E.g., if directory is 'H:\SubFolder\' will now resolve to 'H:\SubFolder' 
09/12/2014||3.0.3||Minor fix to Gqvc.ResolvePath, which now accepts all combinations of paths expect for '.\' when the current directory is the rootfolder 
10/12/2014||3.0.4||Minor fix to Gqvc.CreateDirectory to check successful directory creation for UNC path 
10/12/2014||3.0.5||Minor fix to Gqvc.DeleteDirectory to check successful directory deletion for UNC path 
12/12/2014||3.0.6||Minor fix to Gqvc.DeleteAllQvdFilesFromDirectory for UNC path 
17/12/2014||3.1.0||Added new Optional parameter "QVDName" to Gqvc.StoreDataQVD. This means QVDs can now be stored with names other than in-memory tablenames. Also, added new sub-routine "Gqvc.ReduceDataQvd" which helps to reduce QVD to a given number of records. 
18/12/2014||3.1.1||Fixed bug - Gqvc.DeleteDirectory left dummy file when it failed to delete a directory.  
03/01/2015||4.0.0||Created new tab "Script Macros". Added sub "Gqvc.GetFieldValues" in Field mgmt. "Gqvc.ReduceDataQvd" can now create sample of records.  
19/01/2015||4.0.1||Used *.* to resolve UNC path instead of having to create/delete '__Dummy_$@#.txt' 
21/01/2015||4.0.2||"Gqvc.Macro.v.CreateRandomName" produces relatively more unique numbers and reduces chances of name collision. Updated "GetFieldValues" & "ReduceDataQvd" to use macro definitions. 
18/06/2015||4.0.3||Fix for Gqvc.LogEvent to handle filename with spaces, Gqvc.ResolvePath to handle non-existing directories when called by CreateDirectory.
18/06/2015||4.0.3||Added Gqvc.CleanupMacros to cleanup routine and removed Gqvc.DeleteDirectory routine due to security risk
24/06/2015||4.0.4||Minor fix to Gqvc.CreateCalendarFromField routine, which was excluding last date record & enabled logging to file
09/07/2015||4.0.5||Bug fix on Gqvc.StoreDropAllTablesToQvd. Loop failed to pick correct tablenames when reserved "Gqvc" survived delete.
21/07/2015||4.1.0||Added Gqvc Configuration variables and improved Cleanup routines to remove Gqvc variables & tables in a controlled manner.
27/07/2015||4.2.0||Gqvc.RecursiveDirectory & Gqvc.RecursiveFile released for use. Log management enhanced to use configuration settings.
31/07/2015||4.2.1||GitHub issue #1; Fixed infinite loop bug with Gqvc.RecursiveDirectory, when Gqvc.LogEvent or its helper functions were used as Loop parameters. 
05/08/2015||4.2.2||GitHub issue #2; Fixed bug with Gqvc.LogEvent when using "STORE" command to write to text file.
06/08/2015||4.2.3||GitHub issue #3; Nested calls to Gqvc.ResolvePath by different routines was over-writing v.ResolvedDirectoryPath. 
13/08/2015||4.2.4||Added Gqvc.CreateTable and Gqvc.CloneDirectory routines
13/08/2015||4.2.4||Storing Gqvc reserved tables to QVD is now possible. User should explicitly pass name of the QVD when storing reserved tables.
28/08/2015||4.2.5||GitHub issue #4; Minor fix to Gqvc.Logs. Gqvc.Logs table was sometimes accidently concatenated with other user tables.
22/10/2015||4.2.6||GitHub issue #5; Fixed concatenation of calendar tables in Gqvc.CreateCalendar & Gqvc.CreateCalendarFromField 
30/10/2015||4.2.6||Added two new macro variables, Gqvc.Macro.v.GetSelectedField & Gqvc.Macro.v.SelectedField, to list data of selected field in a list box.
04/11/2015||4.2.6||Calls to Gqvc.CreateDirectory will now result in script failure, if it does not have permissions to create directory and a call to store data in non-existent directory is made
];

LET Gqvc.ChangeLog.v.Version = PEEK('Gqvc.Version',-1,'Gqvc.Version'); 

TRACE 
************************** Gqvc default settings **************************;
TRACE Gqvc Version: $(Gqvc.ChangeLog.v.Version); 
///$tab Gqvc Configuration
// *********************** Gqvc global configuration *********************** 

/* Gqvc.Config.v.SystemAccessMode settings
0 -> Qlikview default and does not require additional security settings
1 -> Creates files/folders; Requires Settings -> "Can Execute External Programs" 
2 -> Can create and delete files/folders; Requires Settings -> "Can Execute External Programs" 
*/
SET Gqvc.Config.v.SystemAccessMode = 0;
TRACE Gqvc.Config.v.SystemAccessMode = $(Gqvc.Config.v.SystemAccessMode);

/* Gqvc.Config.v.LogMode settings
0 -> No log created 
1 -> Log file stored & read as flat file. Log will not be created until script has successfully ran and Gqvc.Cleanup called at the end of script.
2 -> Log file stored as QVD. Log will not be created until script has successfully ran and Gqvc.Cleanup called at the end of script.
3 -> Can create logs, as flat file, at run time; Requires Settings -> "Can Execute External Programs" 
*/ 
SET Gqvc.Config.v.LogMode = 2;
TRACE Gqvc.Config.v.LogMode = $(Gqvc.Config.v.LogMode);

/* Gqvc.Config.v.LogMode settings for Gqvc.Cleanup
0 -> Deletes routines specific variables only
1 -> Deletes macros along with routine specific variables
2 -> Deletes all Gqvc variables except Gqvc.ChangeLog.v.Version 
*/ 
SET Gqvc.Config.v.CleanupVariables = 0;
TRACE Gqvc.Config.v.CleanupVariables = $(Gqvc.Config.v.CleanupVariables);

/* Gqvc.Config.v.LogMode settings for Gqvc.Cleanup
Gqvc.CleanupTables defines a matrix and mode to be deleted. It is a custimizable matrix and can include tables added in future
*/ 
SET Gqvc.Config.v.CleanupTables = 5;
TRACE Gqvc.Config.v.CleanupTables = $(Gqvc.Config.v.CleanupTables);

TRACE ************************** End of Gqvc default settings **************************
;

[Gqvc.CleanupTables]:
LOAD * INLINE [
    CleanupTables, Mode0, Mode1, Mode2, Mode3, Mode4, Mode5
    Gqvc.Version, 0, 1, 0, 0, 1, 1
    Gqvc.ClearVariables, 0, 0, 1, 0, 1, 0
    Gqvc.ScannedFileList, 0, 0, 0, 1, 1, 1
];
// *********************** Gqvc global configuration *********************** 

///$tab Script Macros 
// Macros  
// ****************************** Start Sub ****************************** 
/* 
Param 1 Positive Integer: Position of 1 in the binary string 
Param 2 Positve Integer: Binary string lenght 
Syntax $(Gqvc.Macro.v.CreateBitString(2,3)); 
*/ 
SET Gqvc.Macro.v.CreateBitString = If(Len(Trim($2))=0, Repeat(0,$1-1) & 1, Repeat(0,$1-1) & 1 & Repeat(0,$2-$1)); 

SET Gqvc.Macro.v.DefaultIfEmpty = If(Len(Trim($1))= 0, $2, $1); // Returns second argument if first argument is empty 
SET Gqvc.Macro.v.FieldExists = IF(Len(Trim($1))>0, IsNull(FieldValueCount($1)),-1); // Returns 0 if field exists else -1 
SET Gqvc.Macro.v.TableExists = IF(Len(Trim($1))>0, IsNull(TableNumber($1)),-1); // Returns 0 if table exists else -1 
SET Gqvc.Macro.v.FileExists = IF(Len(Trim($1))>0, IsNull(FileSize($1)),-1); // Returns 0 if file exists else -1 
SET Gqvc.Macro.v.IsReserved = WildMatch($1,'Gqvc.*','_Gqvc.*'); // Returns integer > 0 if table/field name contains "Gqvc" else 0 
SET Gqvc.Macro.v.CreateRandomName =  IF(Len(Trim($1))>0,$1 & '_','__Temp_') & Ceil(pow((Rand()+1)*10,Rand()+pi())); // Creates random name. Argument passed will be part of the name  

/* 
Standard variables required to build dynamic fields in list box. To be used in UI.
Typically you could create three list boxes for dynamic data exploration. Replace '%' with the character you've used in "SET HidePrefix=" statement.
	1. for table selection (optional)
		List box expression (content inside double quotes): "=IF(LEFT($Table,1)<>'%' AND SUBFIELD($Table,'.',1)<>'Gqvc', $Table)"
	2. for field selection
		List box expression (content inside double quotes): "=IF(LEFT($Field,1)<>'%' AND SUBFIELD($Field,'.',1)<>'Gqvc', $Field)"
	3. To display data in a field
		List box expression (content inside double quotes): "=$(v.CMN.SelectedField)"
		List box title (content inside double quotes): "='Field values (' & COUNT($(v.CMN.SelectedField)) & ')'"	
*/ 
LET Gqvc.Macro.v.GetSelectedField = '=' & CHR(39) & '[' & CHR(39) & CHR(38) & 'GETFIELDSELECTIONS(' & CHR(36) & 'Field,' & CHR(39) & CHR(39) & ',1)' & CHR(38) & CHR(39) & ']' & CHR(39);
SET Gqvc.Macro.v.SelectedField = '=Gqvc.Macro.v.GetSelectedField';
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Table to be called via VB macro in QVW 
// Use this code in VB macro script: ExecuteGlobal ActiveDocument.Evaluate("Concat(Gqvc.MacroCode, Chr(10), Gqvc.MacroLine)") 
[Gqvc.ClearVariables]: 
LOAD  
	Gqvc.MacroCode 
	,RowNo() as Gqvc.MacroLine 
INLINE [ 
    Gqvc.MacroCode 
	Sub ClearVariables() 
		Set vars = ActiveDocument.GetVariableDescriptions 
		For i = 0 to vars.Count - 1 
		    Set v = vars.Item(i) 
		    ActiveDocument.RemoveVariable v.Name 
		Next 
	End Sub 
]; 
// ****************************** End Sub ****************************** 
///$tab Table Management 
// Table Management - functions for managing Qlikview in-memory tables. 

// ****************************** Start Sub ****************************** 
/* 
Drops an in memory table, if it exists. 
@param 1 String. TableName: Name of the table to be dropped. 
@syntax CALL Gqvc.DropTable('TableName'); 
*/ 
SUB Gqvc.DropTable(TableName) 
	TRACE Gqvc.DropTable(TableName: [$(TableName)]); 
	 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = -1 THEN 
	    TRACE Table: [$(TableName)], does not exists. Table cannot be dropped.; 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(TableName)')) > 0 AND Len('$(Gqvc.Cleanup.v.Reserved)')=0  THEN 
		TRACE Table: [$(TableName)], is reserved. Table will not be dropped.;      
	ELSE 
	    DROP TABLE [$(TableName)]; 
	    TRACE Table dropped. [$(TableName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Create an in memory table. 
@param 1 String. TableName: Name of the table to be dropped. 
@syntax CALL Gqvc.CreateTable('TableName'); 
*/ 
SUB Gqvc.CreateTable(TableName) 
	TRACE Gqvc.CreateTable(TableName: [$(TableName)]); 
	 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = 0 THEN 
	    TRACE Table: [$(TableName)], already exists. Table cannot be created.; 
	ELSE
		QUALIFY *; 
	    [$(TableName)]:
	    LOAD * INLINE [
	    DummyField
	    ];
	    UNQUALIFY *;
	    
	    TRACE Table created. [$(TableName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Field Management 
// Field Management - functions for managing Qlikview in-memory fields. 


// ****************************** Start Sub ****************************** 
/* 
Drops an in memory field, if it exists. 
@param 1 String. FieldName: Name of the field to be dropped. 
@syntax CALL Gqvc.DropField('FieldName'); 
*/ 
SUB Gqvc.DropField(FieldName) 
	TRACE Gqvc.DropField(FieldName: [$(FieldName)]); 
	 
	IF $(Gqvc.Macro.v.FieldExists('$(FieldName)')) = -1 THEN 
	    TRACE Field: [$(FieldName)], does not exist. Field cannot be dropped.; 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(FieldName)')) > 0 AND Len('$(Gqvc.Cleanup.v.Reserved)')=0  THEN 
		TRACE Field: [$(FieldName)], is reserved. Field will not be dropped.;	     
	ELSE 
	    DROP Field [$(FieldName)]; 
	    TRACE Field dropped. [$(FieldName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 




// ****************************** Start Sub ****************************** 
/** 
Get min & max values of a Field. The values are set in variables names using parameter 2 or fieldname as the prefix. For example, if parameter 2 is 'vStat', the set variables will be: 


	vStat.Min  =  the Min value of the field. 
	vStat.Max  =  the Max value of the field. 
     
@syntax Gqvc.GetFieldValues('LastUpdate', ['vStats'], ['Transactions.qvd']); 


@param 1 String. The field name. 
@param 2 String, Optional. Variable prefix name in which to return values. Variables created will prefix.Max, prefix.Min. 
@param 3 String, Optional. Source that contains the field. If Source ends with '.qvd', source is assumed to be a QVD. If not, Source is a RESIDENT table. If omitted, all values of field are the source. 
*/ 
SUB Gqvc.GetFieldValues(FieldName, ReturnVariable, SourceName) 


	IF Len(Trim('$(SourceName)')) = 0 THEN 
		SET _vSource = ";LOAD FieldValue('$(FieldName)', recno()) as [$(FieldName)] AUTOGENERATE FieldValueCount('$(FieldName)')"; 
	ELSEIF WildMatch('$(SourceName)', '*.???') = 0 THEN 
		SET _vSource = 'RESIDENT $(SourceName)'; 
	ELSEIF WildMatch('$(SourceName)', '*.qvd') > 0 THEN 
		SET _vSource = 'FROM [$(SourceName)] (qvd)'; 
//	ELSE // Can be used to assume text file as source 
//		SET _vSource = 'FROM $(SourceName)';	 
	ENDIF 
	 
	LET Gqvc.v.TempTableName = $(Gqvc.Macro.v.CreateRandomName('__Gqvc.GetFieldValues')); 
	 
	[$(Gqvc.v.TempTableName)]: 
	LOAD  
		Max([$(FieldName)]) as _maxval, 
		Min([$(FieldName)]) as _minval	 
	$(_vSource); 
	 
	LET v.Prefix = $(Gqvc.Macro.v.DefaultIfEmpty('$(ReturnVariable)','$(FieldName)')); 
	LET $(v.Prefix).Max = peek('_maxval'); 
	LET $(v.Prefix).Min = peek('_minval'); 


	DROP table [$(Gqvc.v.TempTableName)]; 


	SET Gqvc.v.TempTableName = ; 
	SET v.Prefix = ; 
	SET _vSource = ; 
END SUB 
// ****************************** End Sub ****************************** 
///$tab QVD Management 
// QVD Management - Functions for managing QVDs 


// ****************************** Start Sub ****************************** 
// Stores in memory table to QVD file. 
// Parameters: 
// @param 1 String. TableName: Name of the table to be written to QVD. 
// @param 2 String. QvdPath: Path of the QVD file to be written. 
// @param 3 String, Optional. QvdName: Name of the QVD file, to be saved, if different from the TableName. 
// @syntax CALL Gqvc.StoreDataQvd('TableName', 'QvdPath'); 
SUB Gqvc.StoreDataQvd(TableName, QvdPath, QvdName) 
	CALL Gqvc.CreateDirectory('$(QvdPath)'); // Ensure directory exists, if not create one if global config allow.
	CALL Gqvc.ResolvePath('$(QvdPath)'); // Resolve path, just in case CreateDirectory failed to create directory or had called LogEvent.
	
	LET Gqvc.QVD.v.StoreQVDPath = '$(v.ResolvedDirectoryPath)';	 
	TRACE Gqvc.StoreDataQvd(TableName:[$(TableName)], QvdPath:[$(Gqvc.QVD.v.StoreQVDPath)]); 

	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = -1 THEN 
	    TRACE Table: [$(TableName)], does not exist. Table cannot be stored.;		 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(TableName)')) > 0 AND LEN(TRIM('$(QvdName)')) = 0  THEN // Allows storing reserved tables by user by different names
		TRACE Table: [$(TableName)], is a reserved table. Table will not be stored.;		 
	ELSE 
		LET Gqvc.Qvd.v.QvdFileName = $(Gqvc.Macro.v.DefaultIfEmpty('$(QvdName)','$(TableName)'));	//IF(LEN(TRIM('$(QvdName)')) > 0,'$(QvdName)','$(TableName)'); 
		STORE [$(TableName)] INTO [$(Gqvc.QVD.v.StoreQVDPath)\$(Gqvc.Qvd.v.QvdFileName).qvd] (qvd); 
		TRACE TableName:[$(TableName)] stored at QvdPath:[$(Gqvc.QVD.v.StoreQVDPath)]; 
	END IF 
	 
	// Cleanup.. 
	LET Gqvc.Qvd.v.QvdFileName = ;
	LET Gqvc.QVD.v.StoreQVDPath =; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores in memory table to QVD file.  Drops in memory table after persisting to QVD. 
// Parameters: 
// @param 1 String. TableName: Name of the table to be written to QVD. 
// @param 2 String. QvdPath: Path of the QVD file to be written. 
// @param 3 String, Optional. QvdName: Name of the QVD file, to be saved, if different from the TableName. 
// @syntax CALL Gqvc.StoreDropDataQvd('TableName', 'QvdPath'); 
SUB Gqvc.StoreDropDataQvd(TableName, QvdPath, QvdName) 
	TRACE Gqvc.StoreDropDataQvd(TableName:[$(TableName)], QvdPath:[$(QvdPath)]); 
    CALL Gqvc.StoreDataQvd('$(TableName)','$(QvdPath)','$(QvdName)'); 
    CALL Gqvc.DropTable('$(TableName)'); 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores all in memory tables to QVD. 
// Parameters: 
// @param 1 String. QvdDirectory: root folder for Qvd storage. 
// @syntax CALL Gqvc.StoreAllTablesToQvd('QvdDirectory'); 
SUB Gqvc.StoreAllTablesToQvd(QvdDirectory) 
        TRACE StoreAllTablesToQvd(QvdDirectory:[$(QvdDirectory)]); 
		 
        FOR i = 0 TO NoOfTables()-1
        	LET Gqvc.QVD.v.TableName	=	TableName(i); 
			CALL Gqvc.StoreDataQvd('$(Gqvc.QVD.v.TableName)',QvdDirectory); 
        NEXT 
      
     // Cleanup.. 
     SET i=;  
     SET Gqvc.QVD.v.TableName=;
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores all in memory tables to QVD and drops the tables. 
// Parameters: 
// @param 1 String. QvdDirectory: root folder for Qvd storage. 
// @syntax CALL Gqvc.StoreDropAllTablesToQvd('QvdDirectory'); 
SUB Gqvc.StoreDropAllTablesToQvd(QvdDirectory) 
        TRACE StoreDropAllTablesToQvd(QvdDirectory:[$(QvdDirectory)]); 
		 
        FOR i = 0 TO NoOfTables()-1
			[Gqvc.TablesToDrop]:
			LOAD
				TABLENAME($(i))	AS Gqvc.TableNameToDrop
			AUTOGENERATE 1;
        NEXT 
		FOR i=0 TO NoOfRows('Gqvc.TablesToDrop')-1
        	LET Gqvc.QVD.v.TableName	=	PEEK('Gqvc.TableNameToDrop',$(i),'Gqvc.TablesToDrop');
        	CALL Gqvc.StoreDropDataQvd('$(Gqvc.QVD.v.TableName)',QvdDirectory);  
		NEXT

	// Drop table
	DROP TABLE [Gqvc.TablesToDrop];
     // Cleanup..
     SET i=; 
     SET Gqvc.QVD.v.TableName=; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Removes all *.qvd files from a directory (and sub directories if parameter is IncludeSubDirectories is set to True() or a none zero value). 

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 Boolean, Optional. IncludeSubDirectories: Delete files from all subdirectories too.  Default is false. 

@syntax CALL Gqvc.DeleteAllQvdFilesFromDirectory('DirectoryPath', ['IncludeSubDirectories']); 
*/ 
SUB Gqvc.DeleteAllQvdFilesFromDirectory(DirectoryPath, IncludeSubDirectories) 
	TRACE DeleteAllQvdFilesFromDirectory(DirectoryPath:[$(DirectoryPath)]) 
		IncludeSubDirectories:[$(IncludeSubDirectories)] ; 
		 
	LET _IncludeSubDirectories = $(Gqvc.Macro.v.DefaultIfEmpty('$(IncludeSubDirectories)',0)); //if(len('$(IncludeSubDirectories)')>0,1,0); 

	CALL Gqvc.ResolvePath('$(DirectoryPath)'); 	
	LET Gqvc.Qvd.v.DeleteQvdFilesPath = '$(v.ResolvedDirectoryPath)';

	IF Gqvc.Config.v.SystemAccessMode <> 2 THEN
		TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Insufficient privilege. No QVDs will be deleted from Directory [$(DirectoryPath)];
		CALL Gqvc.LogEvent('Gqvc.DeleteAllQvdFilesFromDirectory: Insufficient privilege. No QVDs will be deleted from Directory [$(DirectoryPath)]','E');
	ELSEIF FileTime('$(Gqvc.Qvd.v.DeleteQvdFilesPath)\*.*') > 0 THEN 
		 IF(_IncludeSubDirectories) THEN 
			TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)] and ALL sub directories;
			CALL Gqvc.LogWarning('Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)] and ALL sub directories'); 
			EXECUTE cmd /C DEL /S "$(Gqvc.Qvd.v.DeleteQvdFilesPath)\*.qvd"; 
		 ELSE 
			  TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)];
			  CALL Gqvc.LogWarning('Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)]'); 
			  EXECUTE cmd /C DEL "$(Gqvc.Qvd.v.DeleteQvdFilesPath)\*.qvd"; 
		 END IF 
	ELSE 
			TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Directory [$(DirectoryPath)] does not exist. No QVDs deleted;
			CALL Gqvc.LogError('Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)]'); 
	END IF 
	
	// Cleanup
	SET _IncludeSubDirectories=; 
	LET Gqvc.Qvd.v.DeleteQvdFilesPath =;  
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Reduces data from a QVD file to number of record passed as argument.  
// Parameters: 
// @param 1 String. QvdName: Name of the QVD. No ".qvd" extension required in the name. 
// @param 2 String. QvdPath: Path of the QVD file.  
// @param 3 Number, Optional. Number of records to retain in the QVD after reduce. If no value is entered, all data will be removed. Values between 0 and 1 will retain sample records. 
// @syntax CALL Gqvc.ReduceDataQvd('QvdName', 'QvdPath',RecordsToRetain); 
// @E.g., CALL Gqvc.ReduceDataQvd('Sales Data', '..\Data\Sales',100000); 
SUB Gqvc.ReduceDataQvd(QvdName, QvdPath, RecordsToRetain) 

	CALL Gqvc.ResolvePath('$(QvdPath)');
	
	LET Gqvc.Qvd.v.ReduceQvdPath = '$(v.ResolvedDirectoryPath)'; 
	LET Gqvc.Qvd.v.QvdFileName = '$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName).qvd' ; 
	LET Gqvc.Qvd.v.RecordsToRetain = IF(LEN(TRIM('$(RecordsToRetain)'))	= 0, 0, IF(ISNUM('$(RecordsToRetain)')=-1,$(RecordsToRetain),-1)); 
	TRACE Gqvc.ReduceDataQvd(QvdName:[$(QvdName)], QvdPath:[$(Gqvc.Qvd.v.ReduceQvdPath)], RecordsToRetain: [$(RecordsToRetain)]); 


	IF FileTime('$(Gqvc.Qvd.v.QvdFileName)') > 0 THEN 
		LET Gqvc.Qvd.v.QvdNoOfRecords.Original = QvdNoOfRecords('$(Gqvc.Qvd.v.QvdFileName)'); 
		LET Gqvc.Qvd.v.TempTableName = $(Gqvc.Macro.v.CreateRandomName('__Gqvc.ReduceDataQvd')); //'__Dummy_$@#'; 


		IF $(Gqvc.Qvd.v.RecordsToRetain) > $(Gqvc.Qvd.v.QvdNoOfRecords.Original) THEN 
			TRACE QvdName:[$(QvdName)] already has fewer records [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] than given limit [$(RecordsToRetain)]. No reduction of data will happen; 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) > 0 AND $(Gqvc.Qvd.v.RecordsToRetain) < 1 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			SAMPLE $(Gqvc.Qvd.v.RecordsToRetain) 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd) 
			WHERE 1=1; 
	 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(Gqvc.Qvd.v.ReduceQvdPath)', '$(QvdName)'); 
			TRACE QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] and a sample of [$(RecordsToRetain)] records are retained; 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) > 0 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			FIRST $(Gqvc.Qvd.v.RecordsToRetain) 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd); 
	 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(Gqvc.Qvd.v.ReduceQvdPath)', '$(QvdName)'); 
			TRACE QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] to [$(RecordsToRetain)] records; 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) = 0 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			FIRST 1 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd); 
				INNER JOIN ($(Gqvc.Qvd.v.TempTableName)) 
			LOAD * RESIDENT [$(Gqvc.Qvd.v.TempTableName)] WHERE 1=2; 
			 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(Gqvc.Qvd.v.ReduceQvdPath)', '$(QvdName)'); 
			TRACE QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] fully truncated from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] records;			 
		 
		ELSE 
			TRACE 'Invalid argument value for RecordsToRetain. Only positive integers are allowed'; 
			CALL Gqvc.LogEvent('Invalid argument value for RecordsToRetain. Only positive integers are allowed','E'); 
		END IF 


	ELSE 
	    TRACE Qvd:[$(QvdName)], does not exist at QvdPath:[$(Gqvc.Qvd.v.ReduceQvdPath)]. QVD cannot be reduced.;	 
		CALL Gqvc.LogEvent('Qvd:[$(QvdName)], does not exist at QvdPath:[$(Gqvc.Qvd.v.ReduceQvdPath)]. QVD cannot be reduced.','E');	 
	END IF 


	// Cleanup.. 
	LET Gqvc.Qvd.v.RecordsToRetain =;  
	LET Gqvc.Qvd.v.QvdFileName = ; 
	LET Gqvc.Qvd.v.QvdNoOfRecords.Original = ; 
	LET Gqvc.Qvd.v.TempTableName = ;
	LET Gqvc.Qvd.v.ReduceQvdPath = ; 
	 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Directory Management 
// Directory Management - Functions for managing file system 

// ****************************** Start Sub ****************************** 
/* 
Creates a directory on the file system if it does not already exist. 


@param 1 String. DirectoryPath: The path of the directory. 
@syntax CALL Gqvc.CreateDirectory('DirectoryPath'); 
*/ 

SUB Gqvc.CreateDirectory(DirectoryPath) 
	SET v.NonExistingDirAllowed = -1; // To allow Gqvc.ResolvePath to return non-existing directory path
	CALL Gqvc.ResolvePath('$(DirectoryPath)');
	
	LET Gqvc.Dir.v.CreateDirPath = '$(v.ResolvedDirectoryPath)';
	TRACE Gqvc.CreateDirectory(DirectoryPath:[$(Gqvc.Dir.v.CreateDirPath)]); 
	 
	IF FileTime('$(Gqvc.Dir.v.CreateDirPath)\*.*') > 0 THEN 
		TRACE Directory Exists $(Gqvc.Dir.v.CreateDirPath);
	ELSEIF Gqvc.Config.v.SystemAccessMode = 0 THEN
		TRACE Insufficient privilege. Directory [$(Gqvc.Dir.v.CreateDirPath)] cannot be created;
		CALL Gqvc.LogEvent('Insufficient privilege. Directory [$(Gqvc.Dir.v.CreateDirPath)] cannot be created','E'); 
		CALL Gqvc.RaiseFatalError;		
	ELSE 
	    TRACE Creating Directory $(Gqvc.Dir.v.CreateDirPath); 
	    EXECUTE cmd /C mkdir "$(Gqvc.Dir.v.CreateDirPath)";  

		IF IsNull(FileTime('$(Gqvc.Dir.v.CreateDirPath)\*.*'))  THEN 
			TRACE Error creating directory: $(Gqvc.Dir.v.CreateDirPath); 
			CALL Gqvc.LogEvent('Error creating directory: $(Gqvc.Dir.v.CreateDirPath)','E'); 
			CALL Gqvc.RaiseFatalError;
		ELSE
			TRACE Gqvc.CreateDirectory: Directory [$(Gqvc.Dir.v.CreateDirPath)] created;
			CALL Gqvc.LogInformation('Gqvc.CreateDirectory: Directory [$(Gqvc.Dir.v.CreateDirPath)] created'); 
	    END IF     
	END IF
	
	// Cleanup
	SET v.NonExistingDirAllowed =;
	SET Gqvc.Dir.v.CreateDirPath =; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Resolves relative path in absolute path 

@param 1 String. DirectoryPath: The path of the directory. 
@syntax CALL Gqvc.ResolvePath('DirectoryPath'); 
*/ 
SUB Gqvc.ResolvePath(ResolveDirectoryPath)
	TRACE Gqvc.ResolvePath(ResolveDirectoryPath:[$(ResolveDirectoryPath)]); 
	LET v.Path = Replace(DocumentPath(),'\'&DocumentName(),''); 

	// Remove any trailing '\' from the resolved directory path 
	IF	WildMatch('|'&'$(ResolveDirectoryPath)'&'|','|.\|', '|..\|', '|.\*\|', '|..\*\|', '|\\*\|','|*\|') >= 3 THEN 
		LET ResolveDirectoryPath = Left('$(ResolveDirectoryPath)',Len('$(ResolveDirectoryPath)')-1); 
	END IF			 

//	IF FileTime('$(ResolveDirectoryPath)') > 0 THEN 
//		LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
	 
	IF SubStringCount('$(ResolveDirectoryPath)','.\') > 0 THEN // for relaive path 
		IF SubStringCount('\' & '$(ResolveDirectoryPath)' & '\','\.\\') > 0 THEN 
			LET v.ResolvedDirectoryPath = '$(v.Path)'; 
		ELSEIF 	SubStringCount('\' & '$(ResolveDirectoryPath)' & '\','\.\') > 0 THEN 
			LET v.ResolvedDirectoryPath = '$(v.Path)' & '\' & Replace('$(ResolveDirectoryPath)','.\',''); 
		ELSE 
			LET v.NodeCount = SubStringCount('$(ResolveDirectoryPath)','..\'); 
			LET v.FixedPath = Mid('$(ResolveDirectoryPath)',Index('$(ResolveDirectoryPath)','..\',$(v.NodeCount))+3); 
			LET v.ResolvedRelativePath = Left('$(v.Path)',Index('$(v.Path)','\',$(v.NodeCount)*-1)-1); 
			LET v.ResolvedDirectoryPath = '$(v.ResolvedRelativePath)' & If(Len('$(v.FixedPath)')>0,'\'&'$(v.FixedPath)',Null());		 
		END IF	 

	ELSEIF	Left('$(ResolveDirectoryPath)',2) = '\\' THEN // for UNC path 
		IF Right('$(ResolveDirectoryPath)',1) = '\' THEN 
			LET v.ResolvedDirectoryPath = LEFT('$(ResolveDirectoryPath)',LEN('$(ResolveDirectoryPath)')-1); 
		ELSE 
			LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
		END IF 
		 
	ELSEIF FileTime('$(ResolveDirectoryPath)') > 0 THEN 
		LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
	
	ELSEIF v.NonExistingDirAllowed=-1 THEN
		LET v.ResolvedDirectoryPathTemp = '$(ResolveDirectoryPath)'; // temporary place holder
		SET v.NonExistingDirAllowed =; // Reset
		TRACE Gqvc.ResolvePath: Non-existing directory [$(ResolveDirectoryPath)] allowed by Gqvc.CreateDirectory override;
		//CALL Gqvc.LogInformation('Gqvc.ResolvePath: Non-existing directory [$(ResolveDirectoryPath)] allowed by Gqvc.CreateDirectory override');
		LET v.ResolvedDirectoryPath = '$(v.ResolvedDirectoryPathTemp)';
		LET v.ResolvedDirectoryPathTemp =; // Cleanup temp variable
	
	ELSE 
		TRACE Gqvc.ResolvePath: Cannot resolve directory [$(ResolveDirectoryPath)]; 
		CALL Gqvc.LogError('Gqvc.ResolvePath: Cannot resolve directory [$(ResolveDirectoryPath)]');  
		CALL Gqvc.RaiseFatalError;	 
	END IF 

	// Cleanup.. 
	SET v.Path = ; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Recurse through directory path

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 Numeric, default is 0. IncludeSubfolder: 0 -> to scan current directory only, 1 -> to scan all subdirectories
@param 3 String. LoopBack: Name of the subroutine to be called for each directory scan
@param 4 String. LoopBackParm: Argument to be included in a Loopback call
@param 5 Numeric. ParmOverride: Overrides, how and what argument you want to pass to Loop back call
	0 -> To pass only directory path as an argument to calling sub routine or Loop back
	1 -> To pass only LoopBackParm as an argument to calling sub routine or Loop back
	2 -> To pass both directory path and LoopBackParm as arguments to calling sub routine or Loop back
	3 -> To pass both directory path and LoopBackParm, in reverse order, as arguments to calling sub routine or Loop back
	By default -> If Loopback parameter is present, send both directory and LoopBackParm othewise send only Directory
@syntax CALL Gqvc.RecursiveDirectory('DirectoryPath',IncludeSubfolder,'LoopBack','LoopBackParm',ParmOverride]); 
Example: CALL Gqvc.RecursiveDirectory('.\',1,'Gqvc.LogEvent','Repeats log message for each directory scanned',1); 
*/ 
// Initialise
SET Gqvc.Rcrv.v.Mask =;
SET Gqvc.Rcrv.v.IncludeSubFolder =;
SET Gqvc.Rcrv.v.LoopBackParm =;
SET Gqvc.Rcrv.v.ParmOverride =;
SET Gqvc.Rcrv.v.LoopBack =;
SET Gqvc.Rcrv.v.Callback =;

SUB Gqvc.RecursiveDirectory(DirectoryPath,IncludeSubfolder,LoopBack,LoopBackParm,ParmOverride)
	CALL Gqvc.ResolvePath(DirectoryPath);
	
	LET Gqvc.Rcrv.v.DirectoryPath = '$(v.ResolvedDirectoryPath)';
	LET Gqvc.Rcrv.v.Mask = IF(RIGHT('$(Gqvc.Rcrv.v.DirectoryPath)',1) = '\','*','\*');
	LET Gqvc.Rcrv.v.IncludeSubFolder = $(Gqvc.Macro.v.DefaultIfEmpty('$(IncludeSubfolder)',0));
	LET Gqvc.Rcrv.v.LoopBackParm = $(Gqvc.Macro.v.DefaultIfEmpty('$(LoopBackParm)',''));
	LET Gqvc.Rcrv.v.ParmOverride = $(Gqvc.Macro.v.DefaultIfEmpty('$(ParmOverride)',-1));    
	LET Gqvc.Rcrv.v.LoopBack = $(Gqvc.Macro.v.DefaultIfEmpty('$(LoopBack)',''));
	
	// Initialise loopback routine parameters
	LET Gqvc.Rcrv.v.Callback = IF(LEN(TRIM('$(Gqvc.Rcrv.v.LoopBack)'))>0,'CALL $(Gqvc.Rcrv.v.LoopBack)' & CHR(40) & CHR(39) & 
							IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))=0) OR $(Gqvc.Rcrv.v.ParmOverride)=0,'$(Gqvc.Rcrv.v.DirectoryPath)',
								IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))<>0) OR $(Gqvc.Rcrv.v.ParmOverride)=2,'$(Gqvc.Rcrv.v.DirectoryPath)' & CHR(39) & CHR(44) & CHR(39) & '$(Gqvc.Rcrv.v.LoopBackParm)',
									IF($(Gqvc.Rcrv.v.ParmOverride)=3, '$(Gqvc.Rcrv.v.LoopBackParm)' & CHR(39) & CHR(44) & CHR(39) & '$(Gqvc.Rcrv.v.DirectoryPath)',
										IF($(Gqvc.Rcrv.v.ParmOverride)=1, '$(Gqvc.Rcrv.v.LoopBackParm)')))) & CHR(39) & CHR(41),'');
	TRACE Directory is [$(Gqvc.Rcrv.v.DirectoryPath)], Callback request [$(Gqvc.Rcrv.v.Callback)];
	$(Gqvc.Rcrv.v.Callback); // Call loopback routine
	
	IF Gqvc.Rcrv.v.IncludeSubFolder = 1 THEN // Recurse through the directory
		FOR Each Dir in dirlist (Gqvc.Rcrv.v.DirectoryPath & '$(Gqvc.Rcrv.v.Mask)' )
			TRACE Gqvc.RecursiveDirectory('$(Dir)',$(Gqvc.Rcrv.v.IncludeSubFolder),'$(Gqvc.Rcrv.v.LoopBack)','$(Gqvc.Rcrv.v.LoopBackParm)',$(Gqvc.Rcrv.v.ParmOverride)); 
			CALL Gqvc.RecursiveDirectory('$(Dir)',$(Gqvc.Rcrv.v.IncludeSubFolder),'$(Gqvc.Rcrv.v.LoopBack)','$(Gqvc.Rcrv.v.LoopBackParm)',$(Gqvc.Rcrv.v.ParmOverride)); 
		NEXT Dir
	END IF
	
	// Cleanup
	SET Gqvc.Rcrv.v.Callback =;
	SET IncludeSubfolder =;
	SET ParmOverride =;	
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Scan for files in a directory

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 String. FileExtension: File extension that needs to be scanned.
@syntax CALL Gqvc.RecursiveFile('.\','xls'); 
Note: Successful run of Gqvc.RecursiveFile, will create Gqvc.ScannedFileList table. This table can be dropped at the end of the script by a call to Gqvc.Cleanup.
*/ 
SUB Gqvc.RecursiveFile(DirectoryPath, FileExtension)
	FOR Each File IN FILELIST(DirectoryPath &'\*.' & FileExtension)
		[Gqvc.ScannedFileList]:
		LOAD 
			'$(File)' as Gqvc.FileName, 
			FileSize( '$(File)' ) as Gqvc.FileSize, 
			FileTime( '$(File)' ) as Gqvc.FileTime
		AUTOGENERATE 1;
	NEXT File	
END SUB
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Scan for files in a directory

@param 1 String. SourceDirectoryPath: The path of the directory to be replicated. 
@param 2 String. TargetDirectoryPath: Path of the target directory.
@syntax CALL Gqvc.CloneDirectory('C:\QV\Dev','D:\QV\UAT'); 
*/ 
SUB Gqvc.CloneDirectory(SourceDirectoryPath, TargetDirectoryPath)
	TRACE Gqvc.CloneDirectory(SourceDirectoryPath:[$(SourceDirectoryPath)], TargetDirectoryPath:[$(TargetDirectoryPath)]); 
	
	IF MIXMATCH($(Gqvc.Config.v.SystemAccessMode),1,2) > 0 THEN // Check for permissions
	
		CALL Gqvc.ResolvePath('$(SourceDirectoryPath)');
		LET Gqvc.Dir.v.Clone.SrcDir = '$(v.ResolvedDirectoryPath)';
		
		SET v.NonExistingDirAllowed = -1; // To allow Gqvc.ResolvePath to return non-existing directory path
		CALL Gqvc.ResolvePath('$(TargetDirectoryPath)');
		LET Gqvc.Dir.v.Clone.TrgDir = '$(v.ResolvedDirectoryPath)';
		SET v.NonExistingDirAllowed =; // Reset
		
		TRACE Resolved source directory [$(Gqvc.Dir.v.Clone.SrcDir)], target directory [$(Gqvc.Dir.v.Clone.TrgDir)];
		
		IF $(Gqvc.Macro.v.TableExists('Gqvc.RecursiveFile')) = 0 THEN // Ensure Gqvc.RecursiveFile has not been used before
			TRACE Gqvc.CloneDirectory: Table [Gqvc.RecursiveFile] is not empty. CloneDirectory cannot proceed.;
			CALL Gqvc.LogError('Gqvc.CloneDirectory: Table [Gqvc.RecursiveFile] is not empty. CloneDirectory cannot proceed.');   
		
		ELSE	
			CALL Gqvc.RecursiveDirectory('$(Gqvc.Dir.v.Clone.SrcDir)',1,'Gqvc.RecursiveFile','*'); // read all directories
			
			// create new directory path using old structure
			[_Gqvc.ReplicateDir]:
			LOAD DISTINCT *;
			LOAD 
				LEFT(Gqvc.FileName,INDEX(Gqvc.FileName,'\',-1)-1) AS SourceDir,
				REPLACE(LEFT(Gqvc.FileName,INDEX(Gqvc.FileName,'\',-1)-1),'$(Gqvc.Dir.v.Clone.SrcDir)','$(Gqvc.Dir.v.Clone.TrgDir)') AS TargetDir
			RESIDENT 
				Gqvc.ScannedFileList;
			LET Gqvc.Dir.v.Clone.NoOfScannedDir = NOOFROWS('_Gqvc.ReplicateDir');
	
			CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Scanned [$(Gqvc.Dir.v.Clone.NoOfScannedDir)] directories in source [$(Gqvc.Dir.v.Clone.SrcDir)]');
			
			IF $(Gqvc.Dir.v.Clone.NoOfScannedDir) > 0 THEN  // Ensure atleast one sub-directory exists
				LET Gqvc.Dir.v.Clone.Counter = 0;
				// create new directory
				FOR i=0 to NOOFROWS('_Gqvc.ReplicateDir') - 1
					LET Gqvc.Dir.v.Clone.ReproduceDir = PEEK('TargetDir',i,'_Gqvc.ReplicateDir');
					CALL Gqvc.CreateDirectory('$(Gqvc.Dir.v.Clone.ReproduceDir)');
					LET Gqvc.Dir.v.Clone.Counter = $(Gqvc.Dir.v.Clone.Counter) + 1;
					//TRACE Gqvc.CloneDirectory: New directory [$(Gqvc.Dir.v.Clone.ReproduceDir)] created;
					//CALL Gqvc.LogInformation('Gqvc.CloneDirectory: New directory [$(Gqvc.Dir.v.Clone.ReproduceDir)] created');
				NEXT
				TRACE Gqvc.CloneDirectory: Directories cloned or attempted to clone [$(Gqvc.Dir.v.Clone.Counter)];
				CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Directories cloned or attempted to clone [$(Gqvc.Dir.v.Clone.Counter)]');
			ELSE
				TRACE Gqvc.CloneDirectory: Source directory is empty. No directories were cloned;
				CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Source directory is empty. No directories were cloned');				
			END IF
		END IF
	ELSE
		TRACE Insufficient privilege. Directory [$(SourceDirectoryPath)] cannot be cloned; 
		CALL Gqvc.LogError('Insufficient privilege. Directory [$(SourceDirectoryPath)] cannot be cloned');   
	END IF
	
	// Cleanup
	SET Gqvc.Cleanup.v.Reserved = -1;
	CALL Gqvc.DropTable('_Gqvc.ReplicateDir');
	SET Gqvc.Cleanup.v.Reserved =;
	LET Gqvc.Dir.v.Clone.SrcDir =;
	LET Gqvc.Dir.v.Clone.TrgDir =;
	LET Gqvc.Dir.v.Clone.NoOfScannedDir =;
	LET Gqvc.Dir.v.Clone.ReproduceDir =;
	SET i=;
	SET Gqvc.Dir.v.Clone.Counter=;
END SUB
// ****************************** End Sub ****************************** 
///$tab Error Management 
// Error Management - Functions for errors 


// ****************************** Start Sub ****************************** 
/* 
Create fatal error to stop execution of script 
@syntax CALL Gqvc.RaiseFatalError; 
*/ 


SUB Gqvc.RaiseFatalError 
	TRACE Fatal error raised!!; 
	CALL Gqvc.LogEvent('Fatal error raised! Script execution will stop','E'); 
	CALL Gqvc.Cleanup;
	SET ErrorMode = 2; // To force erroring out, even if Error mode is set to 0 by the user. 
	CALL FatalError; // Dummy sub to create script error 
	EXIT Script; 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Log Management 
// Log Management - Functions for creating and maintaining document specific logs 

// ****************************** Start Sub ****************************** 
/* 
Creates a log file and writes event instantly. If a log file does not exists, it creates one, otherwise it appends to the log file. 

@param 1 String. Log message 
@param 2 String, Optional. Log level. Acceptable values 'E', 'I' and 'W' (case insensitive) for Error, Information and Warning respectively. Default is Information.
@param 3 String, Optional. Store path for log file, if different from current directory. By default, log is stored in same directory as the QV doc.
@syntax CALL Gqvc.LogEvent('LogMessage',['LogLevel'],['DirectoryPath']); 
*/

SET Gqvc.Log.v.NewRun = ; // Resets for each run 
SUB Gqvc.LogEvent(LogMessage,LogLevel,DirectoryPath) 

	IF LEN(LogLevel) > 0 THEN 
		LET Gqvc.Log.v.LogLevel = IF(UPPER(LEFT(LogLevel,1)) = 'W','Warning',IF(UPPER(LEFT(LogLevel,1)) = 'E','Error','Information')); 
	ELSE 
		LET Gqvc.Log.v.LogLevel = 'Information';	 
	END IF 
	
	CALL Gqvc.ResolvePath($(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)','.\')));
	
	LET Gqvc.Log.v.LogFilePath = '$(v.ResolvedDirectoryPath)\';
	LET Gqvc.Log.v.LogFileName =  TEXT(REPLACE(DOCUMENTNAME(),SUBFIELD(DOCUMENTNAME(),'.',-1),PICK(MATCH($(Gqvc.Config.v.LogMode),1,2,3),'log','log.qvd','log')));
	LET Gqvc.Log.v.LogExists = IF(FILETIME('$(Gqvc.Log.v.LogFilePath)' & '$(Gqvc.Log.v.LogFileName)')>0,-1,0);
	//IF(FILETIME(REPLACE($(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',DocumentPath())),DOCUMENTNAME(),'')&'$(Gqvc.Log.v.LogFileName)') > 0,-1,0); 
	
	IF MATCH(Gqvc.Config.v.LogMode,1,2)>0 THEN
		LET Gqvc.Log.v.FileFormat = PICK(MATCH(Gqvc.Config.v.LogMode,1,2),'(txt, utf8, embedded labels, delimiter is ' & CHR(39) & '\t' & CHR(39) &', msq)','(qvd)');
//		LET Gqvc.Log.v.Fields = PICK(MATCH(Gqvc.Config.v.LogMode,1,2),'@1 as Gqvc.LogTimestamp,@2 as Gqvc.LogLevel,@3 as Gqvc.User,@4 as Gqvc.LogMessage','Gqvc.LogTimestamp,Gqvc.LogLevel,Gqvc.User,Gqvc.LogMessage');	
		// QlikView store to txt command does not have an option to exclude headers. Hence, the workaround is to store and read header
		LET Gqvc.Log.v.Fields = 'Gqvc.LogTimestamp,Gqvc.LogLevel,Gqvc.User,Gqvc.LogMessage';	
		
		IF $(Gqvc.Macro.v.TableExists('Gqvc.Logs'))=-1 AND Gqvc.Log.v.LogExists=-1 THEN // If in memory tables doesn't exists but file exists then load in memory
			[Gqvc.Logs]:
			LOAD 
				$(Gqvc.Log.v.Fields)
			FROM [$(Gqvc.Log.v.LogFilePath)$(Gqvc.Log.v.LogFileName)] $(Gqvc.Log.v.FileFormat);			
		END IF
		
		LET Gqvc.Log.v.Concat = IF($(Gqvc.Macro.v.TableExists('Gqvc.Logs'))=0,'CONCATENATE ([Gqvc.Logs])',''); // required to identify merge to existing table or is it a new log
		
		IF Len('$(Gqvc.Log.v.NewRun)')=0 THEN
			[Gqvc.Logs]:
			$(Gqvc.Log.v.Concat)
			LOAD
				TIMESTAMP(NOW()) 			AS	Gqvc.LogTimestamp,
				'Information'				AS	Gqvc.LogLevel,
				OSUser()					AS	Gqvc.User,
				'===== New Load ====='		AS	Gqvc.LogMessage
			AUTOGENERATE 1;
			
			SET Gqvc.Log.v.NewRun = 0;
		END IF
		
		[Gqvc.Logs]:
		$(Gqvc.Log.v.Concat)
		LOAD
			TIMESTAMP(NOW()) 			AS	Gqvc.LogTimestamp,
			'$(Gqvc.Log.v.LogLevel)'	AS	Gqvc.LogLevel,
			OSUser()					AS	Gqvc.User,
			'$(LogMessage)'				AS	Gqvc.LogMessage
		AUTOGENERATE 1;
	
	// for 	
	ELSEIF Gqvc.Config.v.LogMode = 3 THEN
		 
		LET Gqvc.Log.v.SingleRedirection = CHR(62); 
		LET Gqvc.Log.v.DoubleRedirection = CHR(62)&CHR(62); 
		LET Gqvc.Log.v.Delimiter = CHR(9); // 9 = Horizontal tab 
		 
		LET Gqvc.Log.v.LogMessage = TIMESTAMP(NOW()) & '$(Gqvc.Log.v.Delimiter)' & '$(Gqvc.Log.v.LogLevel)' & '$(Gqvc.Log.v.Delimiter)' & OSUser() & '$(Gqvc.Log.v.Delimiter)' & '$(LogMessage)'; 
		LET Gqvc.Log.v.NewLoadText = TIMESTAMP(NOW()) & '$(Gqvc.Log.v.Delimiter)' & 'Information' & '$(Gqvc.Log.v.Delimiter)' & OSUser() & '$(Gqvc.Log.v.Delimiter)' & '===== New Load ====='; 
	
		LET Gqvc.Log.v.LogHeader = 'Gqvc.LogTimestamp' & '$(Gqvc.Log.v.Delimiter)' & 'Gqvc.LogLevel' & '$(Gqvc.Log.v.Delimiter)' & 'Gqvc.User' & '$(Gqvc.Log.v.Delimiter)' & 'Gqvc.LogMessage';
	
		TRACE Gqvc.LogEvent(LogMessage:[$(LogMessage)], LogLevel:[$(Gqvc.Log.v.LogLevel)]); 
		IF Gqvc.Log.v.LogExists = -1 THEN 
			IF Len('$(Gqvc.Log.v.NewRun)')=0 THEN 	// check if this is a new run.  
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";					 
				SET Gqvc.Log.v.NewRun = 0; 
			END IF 
			EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogMessage) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";		 
		ELSE 
				//EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.SingleRedirection) "$(Gqvc.Log.v.LogFileName)";
				// BELOW TWO STATEMENTS ARE TO ENSURE COMPATIBILITY ON USING "STORE" COMMAND TO GENERATE LOG
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogHeader) $(Gqvc.Log.v.SingleRedirection) "$(Gqvc.Log.v.LogFileName)";
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";					 
				SET Gqvc.Log.v.NewRun = 0; 
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogMessage) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)"; 
		END IF 
	END IF
	
	// Cleanup.. 
	SET	Gqvc.Log.v.LogExists = ; 
//	 
	SET Gqvc.Log.v.SingleRedirection = ; 
	SET Gqvc.Log.v.DoubleRedirection = ; 
	SET Gqvc.Log.v.LogMessage = ; 
	SET Gqvc.Log.v.LogLevel = ; 
	SET Gqvc.Log.v.NewLoadText = ;  
	SET Gqvc.Log.v.Delimiter = ;
	SET Gqvc.Log.v.LogExists =; 
	SET Gqvc.Log.v.Fields =;
	SET Gqvc.Log.v.Concat =;
	SET Gqvc.Log.v.LogHeader =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Helper functions for easy user call to log event.

@param 1 String. Log message 
@param 2 String, Optional. Store path for log file, if different from current directory. By default, log is stored in same directory as the QV doc.
@syntax CALL Gqvc.LogError('LogMessage',['DirectoryPath']); 
*/
SUB Gqvc.LogError(LogMessage,DirectoryPath)
	LET LogMessage = $(Gqvc.Macro.v.DefaultIfEmpty('$(LogMessage)','Gqvc.LogError invoked with no log message'));
	LET DirectoryPath = $(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',''));
	CALL Gqvc.LogEvent(LogMessage,'E',DirectoryPath)
	// Cleanup
	SET LogMessage=;
	SET DirectoryPath=;
END SUB

SUB Gqvc.LogWarning(LogMessage,DirectoryPath)
	LET LogMessage = $(Gqvc.Macro.v.DefaultIfEmpty('$(LogMessage)','Gqvc.LogWarning invoked with no log message'));
	LET DirectoryPath = $(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',''));
	CALL Gqvc.LogEvent(LogMessage,'W',DirectoryPath)
	// Cleanup
	SET LogMessage=;
	SET DirectoryPath=;
END SUB

SUB Gqvc.LogInformation(LogMessage,DirectoryPath)
	LET LogMessage = $(Gqvc.Macro.v.DefaultIfEmpty('$(LogMessage)','Gqvc.LogInformation invoked with no log message'));
	LET DirectoryPath = $(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',''));
	CALL Gqvc.LogEvent(LogMessage,'I',DirectoryPath)
	// Cleanup
	SET LogMessage=;
	SET DirectoryPath=;
END SUB
// ****************************** End Sub ****************************** 
///$tab Calendar Management 
// Calendar Management - Functions for creating and maintaining generic calendars 


// ****************************** Start Sub ****************************** 
/* 
Builds a generic calendar based on an existing date field, in the data model. 


@param 1 String. Existing date field Name 
@param 2 String. New calendar table name 
@param 3 String, Optional. Calendar field name prefix 


@syntax CALL Gqvc.CreateCalendarFromField('FieldName', 'NewTableName',['FieldPrefix']); 
*/ 
SUB Gqvc.CreateCalendarFromField(FieldName,TableName,FieldPrefix)
 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 THEN 
	    TRACE Table: [$(TableName)], already exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Table: [$(TableName)], already exist. Calendar table cannot be created','E');
	ELSEIF $(Gqvc.Macro.v.FieldExists('$(FieldName)')) = -1 THEN 
	    TRACE Date Field: [$(FieldName)], does not exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Date Field: [$(FieldName)], does not exist. Calendar table cannot be created','E'); 		 
	ELSE 
		[$(TableName)]:
		NOCONCATENATE
		LOAD 
			[_Date]					AS [$(FieldName)],		// Link on Field Name 
			[_Date]					AS [%$(FieldName)],		// Link on %field name 
			YEAR(_Date)				AS [$(FieldPrefix)Year], 
			MONTH(_Date)			AS [$(FieldPrefix)Month], 
			DAY(_Date)				AS [$(FieldPrefix)Day],	 
			WEEK(_Date)				AS [$(FieldPrefix)Week], 
			WEEKDAY(_Date)			AS [$(FieldPrefix)Day Name],	 
			MONTHNAME(_Date)		AS [$(FieldPrefix)Month Year], 
			QUARTERNAME(_Date)		AS [$(FieldPrefix)Quarter Name], 
			'Q' & CEIL(MONTH(_Date)/3)		AS [$(FieldPrefix)Quarter] 
		;			 
		LOAD 
			DATE(_MinDate + IterNo()) AS _Date 
		WHILE 
			_MinDate + IterNo() <= _MaxDate + 1
		;		 
		LOAD 
			MIN(_DateField)-1 AS _MinDate, 
			MAX(_DateField) AS _MaxDate 
		;		 
		LOAD 
			FieldValue('$(FieldName)',RecNo()) AS _DateField 
		AUTOGENERATE 
			FieldValueCount('$(FieldName)');	 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Builds a generic calendar based on a start and end date values. 


@param 1 String. New calendar table name 
@param 2 Number. Calendar start date in numeric format 
@param 3 Number. Calendar end date in numeric format 
@param 4 String, Optional. Calendar field name prefix 


@syntax CALL Gqvc.CreateCalendar('NewTableName','','',['FieldPrefix']); 
*/ 


SUB Gqvc.CreateCalendar(TableName,StartDate,EndDate,FieldPrefix) 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 THEN 
	    TRACE Table: [$(TableName)], already exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Table: [$(TableName)], already exist. Calendar table cannot be created','E');		 
	ELSEIF $(StartDate) > $(EndDate) THEN 
		TRACE Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created;
		CALL Gqvc.LogEvent('Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created','E');	 
	ELSE	 
		[$(TableName)]:
		NOCONCATENATE
		LOAD 
			[_Date]					AS [$(FieldPrefix)Date],		// Link on Field Name 
			NUM([_Date])			AS [%$(FieldPrefix)Date],		// Link on %field name 
			YEAR(_Date)				AS [$(FieldPrefix)Year], 
			MONTH(_Date)			AS [$(FieldPrefix)Month], 
			DAY(_Date)				AS [$(FieldPrefix)Day],	 
			WEEK(_Date)				AS [$(FieldPrefix)Week], 
			WEEKDAY(_Date)			AS [$(FieldPrefix)Day Name],	 
			MONTHNAME(_Date)		AS [$(FieldPrefix)Month Year], 
			QUARTERNAME(_Date)		AS [$(FieldPrefix)Quarter Name], 
			'Q' & CEIL(MONTH(_Date)/3)		AS [$(FieldPrefix)Quarter] 
		;	  
		LOAD 
			DATE(_MinDate + IterNo()) AS _Date 
		WHILE 
			_MinDate + IterNo() <= _MaxDate 
		;		 
		LOAD 
			$(StartDate)-1 AS _MinDate, 
			$(EndDate) AS _MaxDate 
		AUTOGENERATE (1);	 
		; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 
///$tab DB Management 
// ****************************** Start Sub ****************************** 
SUB Gqvc.GetTimestampFromSqlDB(ReturnDBTimestamp) 
/* 
Retrieves the current timestamp from the DB.   
@syntax CALL Gqvc.GetTimestampFromSqlDB; 
*/	
	TempTimestampFromDB: 
	REPLACE LOAD *; 
	SQL SELECT GETDATE() AS CurrentTimestampFromDB; 
	 
	LET ReturnDBTimestamp = TIMESTAMP(FieldValue('CurrentTimestampFromDB',1)); 

	TRACE Gqvc.GetTimestampFromSqlDB:[$(ReturnDBTimestamp)]; 
	CALL Gqvc.DropTable('TempTimestampFromDB'); 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
SUB Gqvc.GetTimestampFromOracleDB(ReturnDBTimestamp) 
/* 
Retrieves the current timestamp from the DB. 
@syntax CALL Gqvc.GetTimestampFromOracleDB; 
*/	 
	TempTimestampFromDB: 
	REPLACE LOAD *; 
	SQL SELECT SYSDATE "CurrentTimestampFromDB" FROM DUAL; 
	 
	LET ReturnDBTimestamp = TIMESTAMP(FieldValue('CurrentTimestampFromDB',1)); 

	TRACE Gqvc.GetTimestampFromOracleDB:[$(ReturnDBTimestamp)]; 
	CALL Gqvc.DropTable('TempTimestampFromDB'); 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Cleanup 
// Cleanup Gqvc created temporary variables, fields and tables 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.Cleanup; 
*/ 

SUB Gqvc.Cleanup
	CALL Gqvc.CleanupLogs
	CALL Gqvc.CleanupReservedTables 
	CALL Gqvc.CleanupVariables 
	IF MATCH($(Gqvc.Config.v.CleanupVariables),1,2) > 0 THEN // Delete macros if config allows
		CALL Gqvc.CleanupMacros
	END IF
	IF MATCH($(Gqvc.Config.v.CleanupVariables),2) > 0 THEN // Delete configuration variables if config allows
		CALL Gqvc.CleanupReservedVariables
	END IF	 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Cleanup Variables 
@syntax CALL Gqvc.CleanupVariables; 
*/ 
SUB Gqvc.CleanupVariables 
	// Directory 
	LET v.ResolvedDirectoryPath =; 
	LET v.NodeCount =; 
	LET v.FixedPath =; 
	LET v.ResolvedRelativePath =; 

	// Log	 
	LET Gqvc.Log.v.NewRun =; 
	 
	// DB 
	LET ReturnDBTimestamp =;
	
	// Recursive routines
	LET Gqvc.Rcrv.v.DirectoryPath =;
	LET Gqvc.Rcrv.v.Mask =;
	LET Gqvc.Rcrv.v.IncludeSubFolder =;
	LET Gqvc.Rcrv.v.LoopBackParm =;
	LET Gqvc.Rcrv.v.ParmOverride =;
	LET Gqvc.Rcrv.v.LoopBack =;
	LET Gqvc.Rcrv.v.Callback =;
	LET Gqvc.Rcrv.v.Counter =;
	
	LET DirectoryPath =;
	LET IncludeSubfolder =;
	LET LoopBack =;
	LET LoopBackParm =;
	LET ParmOverride =;
	LET Dir =;
	LET FileExtension =;
	LET File =;
	
	// Clone dir
	LET Gqvc.Dir.v.Clone.SrcDir =;
	LET Gqvc.Dir.v.Clone.TrgDir =;
	LET Gqvc.Dir.v.Clone.NoOfScannedDir =;
	LET Gqvc.Dir.v.Clone.ReproduceDir =;
	SET i=;
	SET Gqvc.Dir.v.Clone.Counter=;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupMacros; 
*/ 

SUB Gqvc.CleanupMacros 
	LET Gqvc.Macro.v.CreateBitString =; 
	LET Gqvc.Macro.v.CreateRandomName =; 
	LET Gqvc.Macro.v.DefaultIfEmpty =; 
	LET Gqvc.Macro.v.FieldExists =; 	 
	LET Gqvc.Macro.v.FileExists =;
	LET Gqvc.Macro.v.IsReserved =;
	LET Gqvc.Macro.v.TableExists =;
	LET Gqvc.Macro.v.GetSelectedField =;
	LET Gqvc.Macro.v.SelectedField =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupReservedVariables; 
*/ 

SUB Gqvc.CleanupReservedVariables 
	// Gqvc Configuration
	SET Gqvc.Config.v.SystemAccessMode =;
	SET Gqvc.Config.v.LogMode =;
	SET Gqvc.Config.v.CleanupVariables =;
	SET Gqvc.Config.v.CleanupTables =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupReservedTables; 
*/ 

SUB Gqvc.CleanupReservedTables 	
	LET Gqvc.Cleanup.v.Mode = 'Mode'&$(Gqvc.Config.v.CleanupTables);
	
	[Gqvc.CleanupReservedTables]:
	LOAD CleanupTables RESIDENT	Gqvc.CleanupTables WHERE $(Gqvc.Cleanup.v.Mode) = 1;
	
	SET Gqvc.Cleanup.v.Reserved = 1; // Enable deletion of reserved tables
	IF NOOFROWS('Gqvc.CleanupReservedTables') > 0 THEN
		FOR i=0 TO NOOFROWS('Gqvc.CleanupReservedTables') - 1
			LET Gqvc.Cleanup.v.TableName = PEEK('CleanupTables',$(i),'Gqvc.CleanupReservedTables');
			CALL Gqvc.DropTable('$(Gqvc.Cleanup.v.TableName)');
		NEXT
	END IF
	
	// Cleanup
	CALL Gqvc.DropTable('Gqvc.CleanupTables');
	CALL Gqvc.DropTable('Gqvc.CleanupReservedTables');
	
	SET i=;
	SET Gqvc.Cleanup.v.Reserved =;
	SET Gqvc.Cleanup.v.Mode =;
	SET Gqvc.Cleanup.v.TableName =;	
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup Logs 
@syntax CALL Gqvc.CleanupLogs; 
*/ 
SUB Gqvc.CleanupLogs
	IF $(Gqvc.Macro.v.TableExists('Gqvc.Logs')) = 0 THEN 
		STORE [Gqvc.Logs] INTO [$(Gqvc.Log.v.LogFilePath)$(Gqvc.Log.v.LogFileName)] $(Gqvc.Log.v.FileFormat);
		DROP TABLE [Gqvc.Logs];
	END IF
	
	// Cleanup
	SET Gqvc.Log.v.LogFileName = ;
	SET Gqvc.Log.v.LogFilePath = ;
	SET Gqvc.Log.v.FileFormat = ;
	
END SUB
// ****************************** End Sub ****************************** 
