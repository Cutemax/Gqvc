///$tab Info 
// ***************	Generic Qlikview Components Library	*************** 
// ***************	Author: Syed Maqsood	*************** 
// ***************	First version Date: 19/09/2014	*************** 
// ***************	Last modified Date: 29/06/2019	*************** 
///$tab Gqvc Configuration
TRACE 
************************** Gqvc default settings **************************;
// *********************** Gqvc global configuration *********************** 

/* Gqvc.Config.v.SystemAccessMode settings
0 -> Qlikview default and does not require additional security settings
1 -> Creates files/folders; Requires Settings -> "Can Execute External Programs" 
2 -> Can create and delete files/folders; Requires Settings -> "Can Execute External Programs" 
*/
SET Gqvc.Config.v.SystemAccessMode = 0;
TRACE Gqvc.Config.v.SystemAccessMode = $(Gqvc.Config.v.SystemAccessMode);

/* Gqvc.Config.v.LogMode settings
0 -> No log created 
1 -> Log file stored & read as flat file. Log will not be created until script has successfully ran and Gqvc.Cleanup called at the end of script.
2 -> Log file stored as QVD. Log will not be created until script has successfully ran and Gqvc.Cleanup called at the end of script.
3 -> Can create logs, as flat file, at run time; Requires Settings -> "Can Execute External Programs" 
*/ 
SET Gqvc.Config.v.LogMode = 2;
TRACE Gqvc.Config.v.LogMode = $(Gqvc.Config.v.LogMode);

/* Gqvc.Config.v.CleanupVariables settings for Gqvc.Cleanup
0 -> Deletes routines specific variables only
1 -> Deletes macros along with routine specific variables
2 -> Deletes all Gqvc variables except Gqvc.ChangeLog.v.Version 
*/ 
SET Gqvc.Config.v.CleanupVariables = 0;
TRACE Gqvc.Config.v.CleanupVariables = $(Gqvc.Config.v.CleanupVariables);

/* Gqvc.Config.v.CleanupTables settings for Gqvc.Cleanup
Gqvc.CleanupTables defines a matrix and mode to be deleted. It is a customizable matrix and can include tables added in future
*/ 
SET Gqvc.Config.v.CleanupTables = 4;
TRACE Gqvc.Config.v.CleanupTables = $(Gqvc.Config.v.CleanupTables);

TRACE ************************** End of Gqvc default settings **************************
;

[Gqvc.CleanupTables]:
LOAD * INLINE [
    CleanupTables, Mode0, Mode1, Mode2, Mode3, Mode4, Mode5
    Gqvc.Version, 0, 1, 0, 0, 1, 1
    Gqvc.ClearVariables, 0, 0, 1, 0, 1, 0
    Gqvc.ScannedFileList, 0, 0, 0, 1, 1, 1
    Gqvc.ScannedDirList, 0, 0, 0, 1, 1, 1
    Gqvc.HTML.Symbol, 0, 0, 1, 1, 1, 1
];
// *********************** Gqvc global configuration *********************** 

///$tab Change Log 
/* *********************** Change Log *********************** 
Versioning convention 
X.Y.Z ==>	X --> New functionality: when a new tab is created which enhances Gqvc's capabilities. 
			Y --> New sub-routines: when a new sub-routine is created to extend/improve existing components 
			Z --> Bug fixes 
*/ 

[Gqvc.Version]:
LOAD
	DATE#(SUBFIELD([Date||Version||Change Description],'||',1),'DD/MM/YYYY')	AS	Gqvc.Date,
	TRIM(SUBFIELD([Date||Version||Change Description],'||',2))					AS	Gqvc.Version,
	TEXT(TRIM(SUBFIELD([Date||Version||Change Description],'||',3)))			AS	Gqvc.Description
;
LOAD * INLINE [
Date||Version||Change Description 
19/09/2014||1.0.0||First release of the Gqvc 
27/10/2014||1.0.1||Fixed "StoreDropAllTablesToQvd" to drop all tables. The loop was using TableName($(i)) instead of TableName(0) 
03/11/2014||1.1.0||Added new sub-routine "Gqvc.ResolvePath"  to check if directory exists 
19/11/2014||2.0.0||Added new sub-routines (tabs: Field Management and Calendar Management) to create a Generic Field and Calendar Management 
20/11/2014||3.0.0||Added new sub-routine "Gqvc.LogEvent" (tab: Log Management) to create event logs 
20/11/2014||3.0.1||Rectified logic to resolve UNC path. Added log events for errors in creating or deleting directories. Call to Gqvc.RaiseFatalError will now result in terminating script execution 
09/12/2014||3.0.2||Gqvc.ResolvePath can now handle trailing '\' in the directory path. E.g., if directory is 'H:\SubFolder\' will now resolve to 'H:\SubFolder' 
09/12/2014||3.0.3||Minor fix to Gqvc.ResolvePath, which now accepts all combinations of paths expect for '.\' when the current directory is the rootfolder 
10/12/2014||3.0.4||Minor fix to Gqvc.CreateDirectory to check successful directory creation for UNC path 
10/12/2014||3.0.5||Minor fix to Gqvc.DeleteDirectory to check successful directory deletion for UNC path 
12/12/2014||3.0.6||Minor fix to Gqvc.DeleteAllQvdFilesFromDirectory for UNC path 
17/12/2014||3.1.0||Added new Optional parameter "QVDName" to Gqvc.StoreDataQVD. This means QVDs can now be stored with names other than in-memory tablenames. Also, added new sub-routine "Gqvc.ReduceDataQvd" which helps to reduce QVD to a given number of records. 
18/12/2014||3.1.1||Fixed bug - Gqvc.DeleteDirectory left dummy file when it failed to delete a directory.  
03/01/2015||4.0.0||Created new tab "Script Macros". Added sub "Gqvc.GetFieldValues" in Field mgmt. "Gqvc.ReduceDataQvd" can now create sample of records.  
19/01/2015||4.0.1||Used *.* to resolve UNC path instead of having to create/delete '__Dummy_$@#.txt' 
21/01/2015||4.0.2||"Gqvc.Macro.v.CreateRandomName" produces relatively more unique numbers and reduces chances of name collision. Updated "GetFieldValues" & "ReduceDataQvd" to use macro definitions. 
18/06/2015||4.0.3||Fix for Gqvc.LogEvent to handle filename with spaces, Gqvc.ResolvePath to handle non-existing directories when called by CreateDirectory.
18/06/2015||4.0.3||Added Gqvc.CleanupMacros to cleanup routine and removed Gqvc.DeleteDirectory routine due to security risk
24/06/2015||4.0.4||Minor fix to Gqvc.CreateCalendarFromField routine, which was excluding last date record & enabled logging to file
09/07/2015||4.0.5||Bug fix on Gqvc.StoreDropAllTablesToQvd. Loop failed to pick correct tablenames when reserved "Gqvc" survived delete.
21/07/2015||4.1.0||Added Gqvc Configuration variables and improved Cleanup routines to remove Gqvc variables & tables in a controlled manner.
27/07/2015||4.2.0||Gqvc.RecursiveDirectory & Gqvc.RecursiveFile released for use. Log management enhanced to use configuration settings.
31/07/2015||4.2.1||GitHub issue #1; Fixed infinite loop bug with Gqvc.RecursiveDirectory, when Gqvc.LogEvent or its helper functions were used as Loop parameters. 
05/08/2015||4.2.2||GitHub issue #2; Fixed bug with Gqvc.LogEvent when using "STORE" command to write to text file.
06/08/2015||4.2.3||GitHub issue #3; Nested calls to Gqvc.ResolvePath by different routines was over-writing v.ResolvedDirectoryPath. 
13/08/2015||4.2.4||Added Gqvc.CreateTable and Gqvc.CloneDirectory routines
13/08/2015||4.2.4||Storing Gqvc reserved tables to QVD is now possible. User should explicitly pass name of the QVD when storing reserved tables.
28/08/2015||4.2.5||GitHub issue #4; Minor fix to Gqvc.Logs. Gqvc.Logs table was sometimes accidently concatenated with other user tables.
22/10/2015||4.2.6||GitHub issue #5; Fixed concatenation of calendar tables in Gqvc.CreateCalendar & Gqvc.CreateCalendarFromField 
30/10/2015||4.2.6||Added two new macro variables, Gqvc.Macro.v.GetSelectedField & Gqvc.Macro.v.SelectedField, to list data of selected field in a list box.
04/11/2015||4.2.6||Calls to Gqvc.CreateDirectory will now result in script failure, if it does not have permissions to create directory and a call to store data in non-existent directory is made
01/12/2015||4.2.7||GitHub issue #6; Fixed bug; Gqvc.CloneDirectory will capture empty source directory error.
02/12/2015||4.2.8||Added 4th parameter to Gqvc.ReduceDataQvd. Users will be able to create new reduced qvds now.
03/12/2015||4.2.8||Added 3rd parameter to Gqvc.CloneDirectory. Users will now be able to clone empty directories as well.
03/12/2015||4.2.8||Added Gqvc.ScannedDirList table to Gqvc.RecursiveDirectory routine. This table will only be created while traversing non-root directories. 
03/12/2015||4.2.8||Added Gqvc.ScannedDirList to Gqvc.CleanupTables; This will ensure safe delete of the table by clean up routines.
04/12/2015||4.2.8||New objects in UI that gives version, configuration details along with Change log table
08/02/2017||4.2.9||Added Gqvc config help text. Hide tab rows.
28/06/2018||4.2.10||Added Gqvc.CreateWorkingDayCalendar routine
05/02/2019||4.2.11||Added Gqvc.Macro.v.CleanString
14/02/2019||4.2.12||Overhauled Gqvc.GetDataDictionaryFromSqlDB routine. Only OLEDB connection is tested.
30/05/2019||4.2.13||Update for Gqvc.GetDataDictionaryFromSqlDB routine. ODBC connections will now need encrypted user id and password as mandatory arguments.
20/06/2019||4.3.0||Added Gqvc.HTML.Symbol table to map  html tags and ascii character codes. Limited use at present with no supporting Gqvc routines.
29/06/2019||4.3.0||Data extract routines added to support Full, Delta & Delta with deleted records. Limited use with no usecase guidelines and tested only against SQL servre.
];

LET Gqvc.ChangeLog.v.Version = PEEK('Gqvc.Version',-1,'Gqvc.Version'); 

TRACE Gqvc Version: $(Gqvc.ChangeLog.v.Version); 
///$tab Script Macros 
// Macros  
// ****************************** Start Sub ****************************** 
/* 
Param 1 Positive Integer: Position of 1 in the binary string 
Param 2 Positve Integer: Binary string lenght 
Syntax $(Gqvc.Macro.v.CreateBitString(2,3)); 
*/ 
SET Gqvc.Macro.v.CreateBitString = If(Len(Trim($2))=0, Repeat(0,$1-1) & 1, Repeat(0,$1-1) & 1 & Repeat(0,$2-$1)); 
SET Gqvc.Macro.v.DefaultIfEmpty = If(Len(Trim($1))= 0, $2, $1); // Returns second argument if first argument is empty 
SET Gqvc.Macro.v.FieldExists = IF(Len(Trim($1))>0, IsNull(FieldValueCount($1)),-1); // Returns 0 if field exists else -1 
SET Gqvc.Macro.v.TableExists = IF(Len(Trim($1))>0, IsNull(TableNumber($1)),-1); // Returns 0 if table exists else -1 
SET Gqvc.Macro.v.FileExists = IF(Len(Trim($1))>0, IsNull(FileSize($1)),-1); // Returns 0 if file exists else -1 
SET Gqvc.Macro.v.IsReserved = WildMatch($1,'Gqvc.*','_Gqvc.*'); // Returns integer > 0 if table/field name contains "Gqvc" else 0 
SET Gqvc.Macro.v.CreateRandomName =  IF(Len(Trim($1))>0,$1 & '_','__Temp_') & Ceil(pow((Rand()+1)*10,Rand()+pi())); // Creates random name. Argument passed will be part of the name  
SET Gqvc.Macro.v.CleanString = PURGECHAR($1,',./\# *-'); // Removes defined characters from source text. 


/* 
Standard variables required to build dynamic fields in list box. To be used in UI.
Typically you could create three list boxes for dynamic data exploration. Replace '%' with the character you've used in "SET HidePrefix=" statement.
	1. for table selection (optional)
		List box expression (content inside double quotes): "=IF(LEFT($Table,1)<>'%' AND SUBFIELD($Table,'.',1)<>'Gqvc', $Table)"
	2. for field selection
		List box expression (content inside double quotes): "=IF(LEFT($Field,1)<>'%' AND SUBFIELD($Field,'.',1)<>'Gqvc', $Field)"
	3. To display data in a field
		List box expression (content inside double quotes): "=$(Gqvc.Macro.v.SelectedField)"
		List box title (content inside double quotes): "='Field values (' & COUNT($(Gqvc.Macro.v.SelectedField)) & ')'"	
*/ 
LET Gqvc.Macro.v.GetSelectedField = '=' & CHR(39) & '[' & CHR(39) & CHR(38) & 'GETFIELDSELECTIONS(' & CHR(36) & 'Field,' & CHR(39) & CHR(39) & ',1)' & CHR(38) & CHR(39) & ']' & CHR(39);
SET Gqvc.Macro.v.SelectedField = '=Gqvc.Macro.v.GetSelectedField';
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Table to be called via VB macro in QVW 
// Use this code in VB macro script: ExecuteGlobal ActiveDocument.Evaluate("Concat(Gqvc.MacroCode, Chr(10), Gqvc.MacroLine)") 
[Gqvc.ClearVariables]: 
LOAD  
	Gqvc.MacroCode 
	,RowNo() as Gqvc.MacroLine 
INLINE [ 
    Gqvc.MacroCode 
	Sub ClearVariables() 
		Set vars = ActiveDocument.GetVariableDescriptions 
		For i = 0 to vars.Count - 1 
		    Set v = vars.Item(i) 
		    ActiveDocument.RemoveVariable v.Name 
		Next 
	End Sub 
]; 
// ****************************** End Sub ****************************** 
///$tab Table Management 
// Table Management - functions for managing Qlikview in-memory tables. 

// ****************************** Start Sub ****************************** 
/* 
Drops an in memory table, if it exists. 
@param 1 String. TableName: Name of the table to be dropped. 
@syntax CALL Gqvc.DropTable('TableName'); 
*/ 
SUB Gqvc.DropTable(TableName) 
	TRACE Gqvc.DropTable(TableName: [$(TableName)]); 
	 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = -1 THEN 
	    TRACE Table: [$(TableName)], does not exists. Table cannot be dropped.; 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(TableName)')) > 0 AND Len('$(Gqvc.Cleanup.v.Reserved)')=0  THEN 
		TRACE Table: [$(TableName)], is reserved. Table will not be dropped.;      
	ELSE 
	    DROP TABLE [$(TableName)]; 
	    TRACE Table dropped. [$(TableName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Create an in memory table. 
@param 1 String. TableName: Name of the table to be dropped. 
@syntax CALL Gqvc.CreateTable('TableName'); 
*/ 
SUB Gqvc.CreateTable(TableName) 
	TRACE Gqvc.CreateTable(TableName: [$(TableName)]); 
	 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = 0 THEN 
	    TRACE Table: [$(TableName)], already exists. Table cannot be created.; 
	ELSE
		QUALIFY *; 
	    [$(TableName)]:
	    LOAD * INLINE [
	    DummyField
	    ];
	    UNQUALIFY *;
	    
	    TRACE Table created. [$(TableName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Field Management 
// Field Management - functions for managing Qlikview in-memory fields. 


// ****************************** Start Sub ****************************** 
/* 
Drops an in memory field, if it exists. 
@param 1 String. FieldName: Name of the field to be dropped. 
@syntax CALL Gqvc.DropField('FieldName'); 
*/ 
SUB Gqvc.DropField(FieldName) 
	TRACE Gqvc.DropField(FieldName: [$(FieldName)]); 
	 
	IF $(Gqvc.Macro.v.FieldExists('$(FieldName)')) = -1 THEN 
	    TRACE Field: [$(FieldName)], does not exist. Field cannot be dropped.; 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(FieldName)')) > 0 AND Len('$(Gqvc.Cleanup.v.Reserved)')=0  THEN 
		TRACE Field: [$(FieldName)], is reserved. Field will not be dropped.;	     
	ELSE 
	    DROP Field [$(FieldName)]; 
	    TRACE Field dropped. [$(FieldName)]; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 




// ****************************** Start Sub ****************************** 
/** 
Get min & max values of a Field. The values are set in variables names using parameter 2 or fieldname as the prefix. For example, if parameter 2 is 'vStat', the set variables will be: 


	vStat.Min  =  the Min value of the field. 
	vStat.Max  =  the Max value of the field. 
     
@syntax Gqvc.GetFieldValues('LastUpdate', ['vStats'], ['Transactions.qvd']); 


@param 1 String. The field name. 
@param 2 String, Optional. Variable prefix name in which to return values. Variables created will prefix.Max, prefix.Min. 
@param 3 String, Optional. Source that contains the field. If Source ends with '.qvd', source is assumed to be a QVD. If not, Source is a RESIDENT table. If omitted, all values of field are the source. 
*/ 
SUB Gqvc.GetFieldValues(FieldName, ReturnVariable, SourceName) 


	IF Len(Trim('$(SourceName)')) = 0 THEN 
		SET _vSource = ";LOAD FieldValue('$(FieldName)', recno()) as [$(FieldName)] AUTOGENERATE FieldValueCount('$(FieldName)')"; 
	ELSEIF WildMatch('$(SourceName)', '*.???') = 0 THEN 
		SET _vSource = 'RESIDENT $(SourceName)'; 
	ELSEIF WildMatch('$(SourceName)', '*.qvd') > 0 THEN 
		SET _vSource = 'FROM [$(SourceName)] (qvd)'; 
//	ELSE // Can be used to assume text file as source 
//		SET _vSource = 'FROM $(SourceName)';	 
	ENDIF 
	 
	LET Gqvc.v.TempTableName = $(Gqvc.Macro.v.CreateRandomName('__Gqvc.GetFieldValues')); 
	 
	[$(Gqvc.v.TempTableName)]: 
	LOAD  
		Max([$(FieldName)]) as _maxval, 
		Min([$(FieldName)]) as _minval	 
	$(_vSource); 
	 
	LET v.Prefix = $(Gqvc.Macro.v.DefaultIfEmpty('$(ReturnVariable)','$(FieldName)')); 
	LET $(v.Prefix).Max = peek('_maxval'); 
	LET $(v.Prefix).Min = peek('_minval'); 


	DROP table [$(Gqvc.v.TempTableName)]; 


	SET Gqvc.v.TempTableName = ; 
	SET v.Prefix = ; 
	SET _vSource = ; 
END SUB 
// ****************************** End Sub ****************************** 
///$tab QVD Management 
// QVD Management - Functions for managing QVDs 

// ****************************** Start Sub ****************************** 
// Stores in memory table to QVD file. 
// Parameters: 
// @param 1 String. TableName: Name of the table to be written to QVD. 
// @param 2 String. QvdPath: Path of the QVD file to be written. 
// @param 3 String, Optional. QvdName: Name of the QVD file, to be saved, if different from the TableName. 
// @syntax CALL Gqvc.StoreDataQvd('TableName', 'QvdPath'); 
SUB Gqvc.StoreDataQvd(TableName, QvdPath, QvdName) 
	CALL Gqvc.CreateDirectory('$(QvdPath)'); // Ensure directory exists, if not create one if global config allow.
	CALL Gqvc.ResolvePath('$(QvdPath)'); // Resolve path, just in case CreateDirectory failed to create directory or had called LogEvent.
	
	LET Gqvc.QVD.v.StoreQVDPath = '$(v.ResolvedDirectoryPath)';	 
	TRACE Gqvc.StoreDataQvd(TableName:[$(TableName)], QvdPath:[$(Gqvc.QVD.v.StoreQVDPath)]); 

	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) = -1 THEN 
	    TRACE Table: [$(TableName)], does not exist. Table cannot be stored.;		 
	ELSEIF $(Gqvc.Macro.v.IsReserved('$(TableName)')) > 0 AND LEN(TRIM('$(QvdName)')) = 0  THEN // Allows storing reserved tables by user by different names
		TRACE Table: [$(TableName)], is a reserved table. Table will not be stored.;		 
	ELSE 
		LET Gqvc.Qvd.v.QvdFileName = $(Gqvc.Macro.v.DefaultIfEmpty('$(QvdName)','$(TableName)'));	//IF(LEN(TRIM('$(QvdName)')) > 0,'$(QvdName)','$(TableName)'); 
		STORE [$(TableName)] INTO [$(Gqvc.QVD.v.StoreQVDPath)\$(Gqvc.Qvd.v.QvdFileName).qvd] (qvd); 
		TRACE TableName:[$(TableName)] stored at QvdPath:[$(Gqvc.QVD.v.StoreQVDPath)]; 
	END IF 
	 
	// Cleanup.. 
	LET Gqvc.Qvd.v.QvdFileName = ;
	LET Gqvc.QVD.v.StoreQVDPath =; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores in memory table to QVD file.  Drops in memory table after persisting to QVD. 
// Parameters: 
// @param 1 String. TableName: Name of the table to be written to QVD. 
// @param 2 String. QvdPath: Path of the QVD file to be written. 
// @param 3 String, Optional. QvdName: Name of the QVD file, to be saved, if different from the TableName. 
// @syntax CALL Gqvc.StoreDropDataQvd('TableName', 'QvdPath'); 
SUB Gqvc.StoreDropDataQvd(TableName, QvdPath, QvdName) 
	TRACE Gqvc.StoreDropDataQvd(TableName:[$(TableName)], QvdPath:[$(QvdPath)]); 
    CALL Gqvc.StoreDataQvd('$(TableName)','$(QvdPath)','$(QvdName)'); 
    CALL Gqvc.DropTable('$(TableName)'); 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores all in memory tables to QVD. 
// Parameters: 
// @param 1 String. QvdDirectory: root folder for Qvd storage. 
// @syntax CALL Gqvc.StoreAllTablesToQvd('QvdDirectory'); 
SUB Gqvc.StoreAllTablesToQvd(QvdDirectory) 
        TRACE StoreAllTablesToQvd(QvdDirectory:[$(QvdDirectory)]); 
		 
        FOR i = 0 TO NoOfTables()-1
        	LET Gqvc.QVD.v.TableName	=	TableName(i); 
			CALL Gqvc.StoreDataQvd('$(Gqvc.QVD.v.TableName)',QvdDirectory); 
        NEXT 
      
     // Cleanup.. 
     SET i=;  
     SET Gqvc.QVD.v.TableName=;
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Stores all in memory tables to QVD and drops the tables. 
// Parameters: 
// @param 1 String. QvdDirectory: root folder for Qvd storage. 
// @syntax CALL Gqvc.StoreDropAllTablesToQvd('QvdDirectory'); 
SUB Gqvc.StoreDropAllTablesToQvd(QvdDirectory) 
        TRACE StoreDropAllTablesToQvd(QvdDirectory:[$(QvdDirectory)]); 
		 
        FOR i = 0 TO NoOfTables()-1
			[Gqvc.TablesToDrop]:
			LOAD
				TABLENAME($(i))	AS Gqvc.TableNameToDrop
			AUTOGENERATE 1;
        NEXT 
		FOR i=0 TO NoOfRows('Gqvc.TablesToDrop')-1
        	LET Gqvc.QVD.v.TableName	=	PEEK('Gqvc.TableNameToDrop',$(i),'Gqvc.TablesToDrop');
        	CALL Gqvc.StoreDropDataQvd('$(Gqvc.QVD.v.TableName)',QvdDirectory);  
		NEXT

	// Drop table
	DROP TABLE [Gqvc.TablesToDrop];
     // Cleanup..
     SET i=; 
     SET Gqvc.QVD.v.TableName=; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Removes all *.qvd files from a directory (and sub directories if parameter is IncludeSubDirectories is set to True() or a none zero value). 

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 Boolean, Optional. IncludeSubDirectories: Delete files from all subdirectories too.  Default is false. 

@syntax CALL Gqvc.DeleteAllQvdFilesFromDirectory('DirectoryPath', ['IncludeSubDirectories']); 
*/ 
SUB Gqvc.DeleteAllQvdFilesFromDirectory(DirectoryPath, IncludeSubDirectories) 
	TRACE DeleteAllQvdFilesFromDirectory(DirectoryPath:[$(DirectoryPath)]) 
		IncludeSubDirectories:[$(IncludeSubDirectories)] ; 
		 
	LET _IncludeSubDirectories = $(Gqvc.Macro.v.DefaultIfEmpty('$(IncludeSubDirectories)',0)); //if(len('$(IncludeSubDirectories)')>0,1,0); 

	CALL Gqvc.ResolvePath('$(DirectoryPath)'); 	
	LET Gqvc.Qvd.v.DeleteQvdFilesPath = '$(v.ResolvedDirectoryPath)';

	IF Gqvc.Config.v.SystemAccessMode <> 2 THEN
		TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Insufficient privilege. No QVDs will be deleted from Directory [$(DirectoryPath)];
		CALL Gqvc.LogEvent('Gqvc.DeleteAllQvdFilesFromDirectory: Insufficient privilege. No QVDs will be deleted from Directory [$(DirectoryPath)]','E');
	ELSEIF FileTime('$(Gqvc.Qvd.v.DeleteQvdFilesPath)\*.*') > 0 THEN 
		 IF(_IncludeSubDirectories) THEN 
			TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)] and ALL sub directories;
			CALL Gqvc.LogWarning('Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)] and ALL sub directories'); 
			EXECUTE cmd /C DEL /S "$(Gqvc.Qvd.v.DeleteQvdFilesPath)\*.qvd"; 
		 ELSE 
			  TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)];
			  CALL Gqvc.LogWarning('Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)]'); 
			  EXECUTE cmd /C DEL "$(Gqvc.Qvd.v.DeleteQvdFilesPath)\*.qvd"; 
		 END IF 
	ELSE 
			TRACE Gqvc.DeleteAllQvdFilesFromDirectory: Directory [$(DirectoryPath)] does not exist. No QVDs deleted;
			CALL Gqvc.LogError('Gqvc.DeleteAllQvdFilesFromDirectory: Deleting ALL QVDs from Directory [$(DirectoryPath)]'); 
	END IF 
	
	// Cleanup
	SET _IncludeSubDirectories=; 
	LET Gqvc.Qvd.v.DeleteQvdFilesPath =;  
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Reduces data from a QVD file to number of record passed as argument.  
// Parameters: 
// @param 1 String. QvdName: Name of the QVD. No ".qvd" extension required in the name. 
// @param 2 String. QvdPath: Path of the QVD file.  
// @param 3 Number, Optional. Number of records to retain in the QVD after reduce. If no value is entered, all data will be removed. Values between 0 and 1 will retain sample records. 
// @param 4 Number, Optional. To allow over-writing source qvd with reduced qvd or create new qvd with reduced data set. 
//							0 -> New qvd created, file name will be appended with timestamp
//							1, default -> overwirte source qvd (to allow compatibility with all versions upto v4.2.7)
// @syntax CALL Gqvc.ReduceDataQvd('QvdName', 'QvdPath',RecordsToRetain); 
// @E.g., CALL Gqvc.ReduceDataQvd('Sales Data', '..\Data\Sales',100000); 
SUB Gqvc.ReduceDataQvd(QvdName, QvdPath, RecordsToRetain, OverWriteSource) 

	CALL Gqvc.ResolvePath('$(QvdPath)');
	
	LET Gqvc.Qvd.v.OverWriteSource = $(Gqvc.Macro.v.DefaultIfEmpty('$(OverWriteSource)',1)); // Added in v4.2.8
	LET Gqvc.Qvd.v.ReduceQvdPath = '$(v.ResolvedDirectoryPath)'; 
	LET Gqvc.Qvd.v.QvdFileName = '$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName).qvd' ; 
	LET Gqvc.Qvd.v.NewQvdFileName = IF($(Gqvc.Qvd.v.OverWriteSource)=0, '$(QvdName)_' & TIMESTAMP(NOW(1),'YYYYMMDD_hhmmss'), '$(QvdName)'); // Added in v4.2.8
	LET Gqvc.Qvd.v.RecordsToRetain = IF(LEN(TRIM('$(RecordsToRetain)'))	= 0, 0, IF(ISNUM('$(RecordsToRetain)')=-1,$(RecordsToRetain),-1)); 
	
	TRACE Gqvc.ReduceDataQvd(QvdName:[$(QvdName)], QvdPath:[$(Gqvc.Qvd.v.ReduceQvdPath)], RecordsToRetain: [$(RecordsToRetain)], OverWriteSource: [$(Gqvc.Qvd.v.OverWriteSource)]);
	CALL Gqvc.LogWarning('Gqvc.ReduceDataQvd(QvdName:[$(QvdName)]. QvdPath:[$(Gqvc.Qvd.v.ReduceQvdPath)]. RecordsToRetain: [$(RecordsToRetain)]. OverWriteSource: [$(Gqvc.Qvd.v.OverWriteSource)]).'); // Added in v4.2.8

	IF FileTime('$(Gqvc.Qvd.v.QvdFileName)') > 0 THEN 
		LET Gqvc.Qvd.v.QvdNoOfRecords.Original = QvdNoOfRecords('$(Gqvc.Qvd.v.QvdFileName)'); 
		LET Gqvc.Qvd.v.TempTableName = $(Gqvc.Macro.v.CreateRandomName('__Gqvc.ReduceDataQvd')); //'__Dummy_$@#'; 

		IF $(Gqvc.Qvd.v.RecordsToRetain) >= $(Gqvc.Qvd.v.QvdNoOfRecords.Original) THEN 
			TRACE QvdName:[$(QvdName)] already has fewer or same records [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] than given limit [$(RecordsToRetain)]. No reduction of data will happen.;
			CALL Gqvc.LogInformation('QvdName:[$(QvdName)] already has fewer or same records [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] than given limit [$(RecordsToRetain)]. No reduction of data will happen.'); // Added in v4.2.8		 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) > 0 AND $(Gqvc.Qvd.v.RecordsToRetain) < 1 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			SAMPLE $(Gqvc.Qvd.v.RecordsToRetain) 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd) 
			WHERE 1=1; 
	 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(Gqvc.Qvd.v.ReduceQvdPath)', '$(Gqvc.Qvd.v.NewQvdFileName)'); 
			TRACE QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] and a sample of [$(RecordsToRetain)] records are retained; 
			CALL Gqvc.LogInformation('QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] and a sample of [$(RecordsToRetain)] records are retained'); // Added in v4.2.8				
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) > 0 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			FIRST $(Gqvc.Qvd.v.RecordsToRetain) 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd); 
	 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(Gqvc.Qvd.v.ReduceQvdPath)', '$(Gqvc.Qvd.v.NewQvdFileName)'); 
			TRACE QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] to [$(RecordsToRetain)] records;
			CALL Gqvc.LogInformation('QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] reduced from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] to [$(RecordsToRetain)] records'); // Added in v4.2.8			 
		 
		ELSEIF $(Gqvc.Qvd.v.RecordsToRetain) = 0 THEN 
			[$(Gqvc.Qvd.v.TempTableName)]: 
			NOCONCATENATE 
			FIRST 1 
			LOAD * FROM [$(Gqvc.Qvd.v.QvdFileName)] (qvd); 
				INNER JOIN ($(Gqvc.Qvd.v.TempTableName)) 
			LOAD * RESIDENT [$(Gqvc.Qvd.v.TempTableName)] WHERE 1=2; 
			 
			CALL Gqvc.StoreDropDataQvd('$(Gqvc.Qvd.v.TempTableName)', '$(Gqvc.Qvd.v.ReduceQvdPath)', '$(Gqvc.Qvd.v.NewQvdFileName)'); 
			TRACE QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] fully truncated from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] records;
			CALL Gqvc.LogInformation('QvdName:[$(Gqvc.Qvd.v.ReduceQvdPath)\$(QvdName)] fully truncated from [$(Gqvc.Qvd.v.QvdNoOfRecords.Original)] records');	// Added in v4.2.8						 
		 
		ELSE 
			TRACE 'Invalid argument value for RecordsToRetain. Only positive integers are allowed'; 
			CALL Gqvc.LogEvent('Invalid argument value for RecordsToRetain. Only positive integers are allowed','E'); 
		END IF 

	ELSE 
	    TRACE Qvd:[$(QvdName)], does not exist at QvdPath:[$(Gqvc.Qvd.v.ReduceQvdPath)]. QVD cannot be reduced.;	 
		CALL Gqvc.LogEvent('Qvd:[$(QvdName)], does not exist at QvdPath:[$(Gqvc.Qvd.v.ReduceQvdPath)]. QVD cannot be reduced.','E');	 
	END IF 

	// Cleanup.. 
	LET Gqvc.Qvd.v.RecordsToRetain =;  
	LET Gqvc.Qvd.v.QvdFileName = ; 
	LET Gqvc.Qvd.v.QvdNoOfRecords.Original = ; 
	LET Gqvc.Qvd.v.TempTableName = ;
	LET Gqvc.Qvd.v.ReduceQvdPath = ;
	LET Gqvc.Qvd.v.NewQvdFileName = ;
	LET Gqvc.Qvd.v.OverWriteSource = ; 
	 
	LET QvdName =;
	LET QvdPath =;
	LET RecordsToRetain =;
	LET OverWriteSource =;
END SUB 
// ****************************** End Sub ****************************** 
///$tab Directory Management 
// Directory Management - Functions for managing file system 

// ****************************** Start Sub ****************************** 
/* 
Creates a directory on the file system if it does not already exist. 


@param 1 String. DirectoryPath: The path of the directory. 
@syntax CALL Gqvc.CreateDirectory('DirectoryPath'); 
*/ 

SUB Gqvc.CreateDirectory(DirectoryPath) 
	SET v.NonExistingDirAllowed = -1; // To allow Gqvc.ResolvePath to return non-existing directory path
	CALL Gqvc.ResolvePath('$(DirectoryPath)');
	
	LET Gqvc.Dir.v.CreateDirPath = '$(v.ResolvedDirectoryPath)';
	TRACE Gqvc.CreateDirectory(DirectoryPath:[$(Gqvc.Dir.v.CreateDirPath)]); 
	 
	IF FileTime('$(Gqvc.Dir.v.CreateDirPath)\*.*') > 0 THEN 
		TRACE Directory Exists $(Gqvc.Dir.v.CreateDirPath);
	ELSEIF Gqvc.Config.v.SystemAccessMode = 0 THEN
		TRACE Insufficient privilege. Directory [$(Gqvc.Dir.v.CreateDirPath)] cannot be created;
		CALL Gqvc.LogEvent('Insufficient privilege. Directory [$(Gqvc.Dir.v.CreateDirPath)] cannot be created','E'); 
		CALL Gqvc.RaiseFatalError;		
	ELSE 
	    TRACE Creating Directory $(Gqvc.Dir.v.CreateDirPath); 
	    EXECUTE cmd /C mkdir "$(Gqvc.Dir.v.CreateDirPath)";  

		IF IsNull(FileTime('$(Gqvc.Dir.v.CreateDirPath)\*.*'))  THEN 
			TRACE Error creating directory: $(Gqvc.Dir.v.CreateDirPath); 
			CALL Gqvc.LogEvent('Error creating directory: $(Gqvc.Dir.v.CreateDirPath)','E'); 
			CALL Gqvc.RaiseFatalError;
		ELSE
			TRACE Gqvc.CreateDirectory: Directory [$(Gqvc.Dir.v.CreateDirPath)] created;
			CALL Gqvc.LogInformation('Gqvc.CreateDirectory: Directory [$(Gqvc.Dir.v.CreateDirPath)] created'); 
	    END IF     
	END IF
	
	// Cleanup
	SET v.NonExistingDirAllowed =;
	SET Gqvc.Dir.v.CreateDirPath =; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Resolves relative path in absolute path 

@param 1 String. DirectoryPath: The path of the directory. 
@syntax CALL Gqvc.ResolvePath('DirectoryPath'); 
*/ 
SUB Gqvc.ResolvePath(ResolveDirectoryPath)
	TRACE Gqvc.ResolvePath(ResolveDirectoryPath:[$(ResolveDirectoryPath)]); 
	LET v.Path = Replace(DocumentPath(),'\'&DocumentName(),''); 

	// Remove any trailing '\' from the resolved directory path 
	IF	WildMatch('|'&'$(ResolveDirectoryPath)'&'|','|.\|', '|..\|', '|.\*\|', '|..\*\|', '|\\*\|','|*\|') >= 3 THEN 
		LET ResolveDirectoryPath = Left('$(ResolveDirectoryPath)',Len('$(ResolveDirectoryPath)')-1); 
	END IF			 

//	IF FileTime('$(ResolveDirectoryPath)') > 0 THEN 
//		LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
	 
	IF SubStringCount('$(ResolveDirectoryPath)','.\') > 0 THEN // for relaive path 
		IF SubStringCount('\' & '$(ResolveDirectoryPath)' & '\','\.\\') > 0 THEN 
			LET v.ResolvedDirectoryPath = '$(v.Path)'; 
		ELSEIF 	SubStringCount('\' & '$(ResolveDirectoryPath)' & '\','\.\') > 0 THEN 
			LET v.ResolvedDirectoryPath = '$(v.Path)' & '\' & Replace('$(ResolveDirectoryPath)','.\',''); 
		ELSE 
			LET v.NodeCount = SubStringCount('$(ResolveDirectoryPath)','..\'); 
			LET v.FixedPath = Mid('$(ResolveDirectoryPath)',Index('$(ResolveDirectoryPath)','..\',$(v.NodeCount))+3); 
			LET v.ResolvedRelativePath = Left('$(v.Path)',Index('$(v.Path)','\',$(v.NodeCount)*-1)-1); 
			LET v.ResolvedDirectoryPath = '$(v.ResolvedRelativePath)' & If(Len('$(v.FixedPath)')>0,'\'&'$(v.FixedPath)',Null());		 
		END IF	 

	ELSEIF	Left('$(ResolveDirectoryPath)',2) = '\\' THEN // for UNC path 
		IF Right('$(ResolveDirectoryPath)',1) = '\' THEN 
			LET v.ResolvedDirectoryPath = LEFT('$(ResolveDirectoryPath)',LEN('$(ResolveDirectoryPath)')-1); 
		ELSE 
			LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
		END IF 
		 
	ELSEIF FileTime('$(ResolveDirectoryPath)') > 0 THEN 
		LET v.ResolvedDirectoryPath = '$(ResolveDirectoryPath)'; 
	
	ELSEIF v.NonExistingDirAllowed=-1 THEN
		LET v.ResolvedDirectoryPathTemp = '$(ResolveDirectoryPath)'; // temporary place holder
		SET v.NonExistingDirAllowed =; // Reset
		TRACE Gqvc.ResolvePath: Non-existing directory [$(ResolveDirectoryPath)] allowed by Gqvc.CreateDirectory override;
		//CALL Gqvc.LogInformation('Gqvc.ResolvePath: Non-existing directory [$(ResolveDirectoryPath)] allowed by Gqvc.CreateDirectory override');
		LET v.ResolvedDirectoryPath = '$(v.ResolvedDirectoryPathTemp)';
		LET v.ResolvedDirectoryPathTemp =; // Cleanup temp variable
	
	ELSE 
		TRACE Gqvc.ResolvePath: Cannot resolve directory [$(ResolveDirectoryPath)]; 
		CALL Gqvc.LogError('Gqvc.ResolvePath: Cannot resolve directory [$(ResolveDirectoryPath)]');  
		CALL Gqvc.RaiseFatalError;	 
	END IF 

	// Cleanup.. 
	SET v.Path = ; 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Recurse through directory path

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 Numeric, default is 0. IncludeSubfolder: 0 -> to scan current directory only, 1 -> to scan all subdirectories
@param 3 String. LoopBack: Name of the subroutine to be called for each directory scan
@param 4 String. LoopBackParm: Argument to be included in a Loopback call
@param 5 Numeric. ParmOverride: Overrides, how and what argument you want to pass to Loop back call
	0 -> To pass only directory path as an argument to calling sub routine or Loop back
	1 -> To pass only LoopBackParm as an argument to calling sub routine or Loop back
	2 -> To pass both directory path and LoopBackParm as arguments to calling sub routine or Loop back
	3 -> To pass both directory path and LoopBackParm, in reverse order, as arguments to calling sub routine or Loop back
	By default -> If Loopback parameter is present, send both directory and LoopBackParm othewise send only Directory
@syntax CALL Gqvc.RecursiveDirectory('DirectoryPath',IncludeSubfolder,'LoopBack','LoopBackParm',ParmOverride]); 
Example: CALL Gqvc.RecursiveDirectory('.\',1,'Gqvc.LogEvent','Repeats log message for each directory scanned',1); 
*/ 
// Initialise
SET Gqvc.Rcrv.v.Mask =;
SET Gqvc.Rcrv.v.IncludeSubFolder =;
SET Gqvc.Rcrv.v.LoopBackParm =;
SET Gqvc.Rcrv.v.ParmOverride =;
SET Gqvc.Rcrv.v.LoopBack =;
SET Gqvc.Rcrv.v.Callback =;

SUB Gqvc.RecursiveDirectory(DirectoryPath,IncludeSubfolder,LoopBack,LoopBackParm,ParmOverride)
	CALL Gqvc.ResolvePath(DirectoryPath);
	
	LET Gqvc.Rcrv.v.DirectoryPath = '$(v.ResolvedDirectoryPath)';
	LET Gqvc.Rcrv.v.Mask = IF(RIGHT('$(Gqvc.Rcrv.v.DirectoryPath)',1) = '\','*','\*');
	LET Gqvc.Rcrv.v.IncludeSubFolder = $(Gqvc.Macro.v.DefaultIfEmpty('$(IncludeSubfolder)',0));
	LET Gqvc.Rcrv.v.LoopBackParm = $(Gqvc.Macro.v.DefaultIfEmpty('$(LoopBackParm)',''));
	LET Gqvc.Rcrv.v.ParmOverride = $(Gqvc.Macro.v.DefaultIfEmpty('$(ParmOverride)',-1));    
	LET Gqvc.Rcrv.v.LoopBack = $(Gqvc.Macro.v.DefaultIfEmpty('$(LoopBack)',''));
	
	// Initialise loopback routine parameters
	LET Gqvc.Rcrv.v.Callback = IF(LEN(TRIM('$(Gqvc.Rcrv.v.LoopBack)'))>0,'CALL $(Gqvc.Rcrv.v.LoopBack)' & CHR(40) & CHR(39) & 
							IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))=0) OR $(Gqvc.Rcrv.v.ParmOverride)=0,'$(Gqvc.Rcrv.v.DirectoryPath)',
								IF(($(Gqvc.Rcrv.v.ParmOverride)=-1 AND LEN(TRIM('$(Gqvc.Rcrv.v.LoopBackParm)'))<>0) OR $(Gqvc.Rcrv.v.ParmOverride)=2,'$(Gqvc.Rcrv.v.DirectoryPath)' & CHR(39) & CHR(44) & CHR(39) & '$(Gqvc.Rcrv.v.LoopBackParm)',
									IF($(Gqvc.Rcrv.v.ParmOverride)=3, '$(Gqvc.Rcrv.v.LoopBackParm)' & CHR(39) & CHR(44) & CHR(39) & '$(Gqvc.Rcrv.v.DirectoryPath)',
										IF($(Gqvc.Rcrv.v.ParmOverride)=1, '$(Gqvc.Rcrv.v.LoopBackParm)')))) & CHR(39) & CHR(41),'');
	TRACE Directory is [$(Gqvc.Rcrv.v.DirectoryPath)], Callback request [$(Gqvc.Rcrv.v.Callback)];
	$(Gqvc.Rcrv.v.Callback); // Call loopback routine

	IF Gqvc.Rcrv.v.IncludeSubFolder = 1 THEN // Recurse through the directory
		FOR Each Dir in dirlist (Gqvc.Rcrv.v.DirectoryPath & '$(Gqvc.Rcrv.v.Mask)' )
		
			[Gqvc.ScannedDirList]: // Capture directories scanned; introduced in v4.2.8
			LOAD 
				'$(Dir)' as Gqvc.DirName, 
				FileSize( '$(Dir)' ) as Gqvc.DirSize, // funtion does not work on directory
				FileTime( '$(Dir)' ) as Gqvc.DirTime
			AUTOGENERATE 1;
		
			TRACE Gqvc.RecursiveDirectory('$(Dir)',$(Gqvc.Rcrv.v.IncludeSubFolder),'$(Gqvc.Rcrv.v.LoopBack)','$(Gqvc.Rcrv.v.LoopBackParm)',$(Gqvc.Rcrv.v.ParmOverride)); 
			CALL Gqvc.RecursiveDirectory('$(Dir)',$(Gqvc.Rcrv.v.IncludeSubFolder),'$(Gqvc.Rcrv.v.LoopBack)','$(Gqvc.Rcrv.v.LoopBackParm)',$(Gqvc.Rcrv.v.ParmOverride)); 
		NEXT Dir
	END IF
	
	// Cleanup
	SET Gqvc.Rcrv.v.Callback =;
	SET IncludeSubfolder =;
	SET ParmOverride =;	
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Scan for files in a directory

@param 1 String. DirectoryPath: The path of the directory. 
@param 2 String. FileExtension: File extension that needs to be scanned.
@syntax CALL Gqvc.RecursiveFile('.\','xls'); 
Note: Successful run of Gqvc.RecursiveFile, will create Gqvc.ScannedFileList table. This table can be dropped at the end of the script by a call to Gqvc.Cleanup.
*/ 
SUB Gqvc.RecursiveFile(DirectoryPath, FileExtension)
	FOR Each File IN FILELIST(DirectoryPath &'\*.' & FileExtension)
		[Gqvc.ScannedFileList]:
		LOAD 
			'$(File)' as Gqvc.FileName, 
			FileSize( '$(File)' ) as Gqvc.FileSize, 
			FileTime( '$(File)' ) as Gqvc.FileTime
		AUTOGENERATE 1;
	NEXT File	
END SUB
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Creates empty directory structure based on source directory tree. 
This routines is particularly helpful in mirgrating apps between environments. 
Note: 
	1. Directories that do not have any file in it can now be cloned as well.
	2. Root directory will not be a part of new structure created. Hence, if root directory is required, it has to be explicitly mentioned in the target directory path.

@param 1 String. SourceDirectoryPath: The path of the directory to be replicated. 
@param 2 String. TargetDirectoryPath: Path of the target directory.
@param 3 Numeric (Optional), default is 0. CloneEmpty: Supports cloning of empty directories, which was not possible in versions prior to v4.2.8
	0 -> To clone non-empty directories. Supports routines prior to v4.2.8
	1 -> To clone empty directories as well. New functionality.
@syntax CALL Gqvc.CloneDirectory('C:\QV\Dev','D:\QV\UAT', 1); 
*/ 
SUB Gqvc.CloneDirectory(SourceDirectoryPath, TargetDirectoryPath, CloneEmpty)
	TRACE Gqvc.CloneDirectory(SourceDirectoryPath:[$(SourceDirectoryPath)], TargetDirectoryPath:[$(TargetDirectoryPath)]); 
	
	IF MIXMATCH($(Gqvc.Config.v.SystemAccessMode),1,2) > 0 THEN // Check for permissions
	
		CALL Gqvc.ResolvePath('$(SourceDirectoryPath)');
		LET Gqvc.Dir.v.Clone.SrcDir = '$(v.ResolvedDirectoryPath)';
		
		SET v.NonExistingDirAllowed = -1; // To allow Gqvc.ResolvePath to return non-existing directory path
		CALL Gqvc.ResolvePath('$(TargetDirectoryPath)');
		LET Gqvc.Dir.v.Clone.TrgDir = '$(v.ResolvedDirectoryPath)';
		SET v.NonExistingDirAllowed =; // Reset
		
		TRACE Resolved source directory [$(Gqvc.Dir.v.Clone.SrcDir)], target directory [$(Gqvc.Dir.v.Clone.TrgDir)];
		
		LET Gqvc.Dir.v.Clone.CloneEmpty = $(Gqvc.Macro.v.DefaultIfEmpty('$(CloneEmpty)',0));
		
		IF $(Gqvc.Dir.v.Clone.CloneEmpty)=1 THEN			// Clone all directories in the source directory tree. Added in v4.2.8
		
			IF $(Gqvc.Macro.v.TableExists('Gqvc.ScannedDirList')) = 0 THEN // Ensure Gqvc.ScannedDirList has not been used before
				TRACE Gqvc.CloneDirectory: Table [Gqvc.ScannedDirList] is not empty. CloneDirectory cannot proceed.;
				CALL Gqvc.LogError('Gqvc.CloneDirectory: Table [Gqvc.ScannedDirList] is not empty. CloneDirectory cannot proceed.');   
			
			ELSE	
				CALL Gqvc.RecursiveDirectory('$(Gqvc.Dir.v.Clone.SrcDir)',1); // read all directories
				
				// Check for non-empty directory structure
				IF $(Gqvc.Macro.v.TableExists('Gqvc.ScannedDirList')) = -1 OR NOOFROWS('Gqvc.ScannedDirList') = 0 THEN
					CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Table [Gqvc.ScannedDirList] is empty. Ensure source directory is not empty.');
					CALL Gqvc.LogError('Gqvc.CloneDirectory: Empty or invalid source directory structure. CloneDirectory cannot proceed.');
				
				// create new directory path using old structure	
				ELSE
				
					[_Gqvc.ReplicateDir]:
					LOAD DISTINCT *;
					LOAD 
						Gqvc.DirName AS SourceDir,
						REPLACE(Gqvc.DirName,'$(Gqvc.Dir.v.Clone.SrcDir)','$(Gqvc.Dir.v.Clone.TrgDir)') AS TargetDir
					RESIDENT 
						Gqvc.ScannedDirList;
					LET Gqvc.Dir.v.Clone.NoOfScannedDir = NOOFROWS('_Gqvc.ReplicateDir');
			
					CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Scanned [$(Gqvc.Dir.v.Clone.NoOfScannedDir)] directories in source [$(Gqvc.Dir.v.Clone.SrcDir)]');
					
					IF $(Gqvc.Dir.v.Clone.NoOfScannedDir) > 0 THEN  // Ensure atleast one sub-directory exists
						LET Gqvc.Dir.v.Clone.Counter = 0;
						// create new directory
						FOR i=0 to NOOFROWS('_Gqvc.ReplicateDir') - 1
							LET Gqvc.Dir.v.Clone.ReproduceDir = PEEK('TargetDir',i,'_Gqvc.ReplicateDir');
							CALL Gqvc.CreateDirectory('$(Gqvc.Dir.v.Clone.ReproduceDir)');
							LET Gqvc.Dir.v.Clone.Counter = $(Gqvc.Dir.v.Clone.Counter) + 1;
							//TRACE Gqvc.CloneDirectory: New directory [$(Gqvc.Dir.v.Clone.ReproduceDir)] created;
							//CALL Gqvc.LogInformation('Gqvc.CloneDirectory: New directory [$(Gqvc.Dir.v.Clone.ReproduceDir)] created');
						NEXT
						TRACE Gqvc.CloneDirectory: Directories cloned or attempted to clone [$(Gqvc.Dir.v.Clone.Counter)];
						CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Directories cloned or attempted to clone [$(Gqvc.Dir.v.Clone.Counter)]');
					ELSE
						TRACE Gqvc.CloneDirectory: Source directory is empty. No directories were cloned;
						CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Source directory is empty. No directories were cloned');				
					END IF
				END IF
			END IF
		
		ELSE
		
			IF $(Gqvc.Macro.v.TableExists('Gqvc.ScannedFileList')) = 0 THEN // Ensure Gqvc.ScannedFileList has not been used before
				TRACE Gqvc.CloneDirectory: Table [Gqvc.ScannedFileList] is not empty. CloneDirectory cannot proceed.;
				CALL Gqvc.LogError('Gqvc.CloneDirectory: Table [Gqvc.ScannedFileList] is not empty. CloneDirectory cannot proceed.');   
			
			ELSE	
				CALL Gqvc.RecursiveDirectory('$(Gqvc.Dir.v.Clone.SrcDir)',1,'Gqvc.RecursiveFile','*'); // read all directories
				
				// Check for non-empty directory structure
				IF $(Gqvc.Macro.v.TableExists('Gqvc.ScannedFileList')) = -1 OR NOOFROWS('Gqvc.ScannedFileList') = 0 THEN
					CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Table [Gqvc.ScannedFileList] is empty. Ensure source directory is not empty.');
					CALL Gqvc.LogError('Gqvc.CloneDirectory: Empty or invalid source directory structure. CloneDirectory cannot proceed.');
				
				// create new directory path using old structure	
				ELSE
				
					[_Gqvc.ReplicateDir]:
					LOAD DISTINCT *;
					LOAD 
						LEFT(Gqvc.FileName,INDEX(Gqvc.FileName,'\',-1)-1) AS SourceDir,
						REPLACE(LEFT(Gqvc.FileName,INDEX(Gqvc.FileName,'\',-1)-1),'$(Gqvc.Dir.v.Clone.SrcDir)','$(Gqvc.Dir.v.Clone.TrgDir)') AS TargetDir
					RESIDENT 
						Gqvc.ScannedFileList;
					LET Gqvc.Dir.v.Clone.NoOfScannedDir = NOOFROWS('_Gqvc.ReplicateDir');
			
					CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Scanned [$(Gqvc.Dir.v.Clone.NoOfScannedDir)] directories in source [$(Gqvc.Dir.v.Clone.SrcDir)]');
					
					IF $(Gqvc.Dir.v.Clone.NoOfScannedDir) > 0 THEN  // Ensure atleast one sub-directory exists
						LET Gqvc.Dir.v.Clone.Counter = 0;
						// create new directory
						FOR i=0 to NOOFROWS('_Gqvc.ReplicateDir') - 1
							LET Gqvc.Dir.v.Clone.ReproduceDir = PEEK('TargetDir',i,'_Gqvc.ReplicateDir');
							CALL Gqvc.CreateDirectory('$(Gqvc.Dir.v.Clone.ReproduceDir)');
							LET Gqvc.Dir.v.Clone.Counter = $(Gqvc.Dir.v.Clone.Counter) + 1;
							//TRACE Gqvc.CloneDirectory: New directory [$(Gqvc.Dir.v.Clone.ReproduceDir)] created;
							//CALL Gqvc.LogInformation('Gqvc.CloneDirectory: New directory [$(Gqvc.Dir.v.Clone.ReproduceDir)] created');
						NEXT
						TRACE Gqvc.CloneDirectory: Directories cloned or attempted to clone [$(Gqvc.Dir.v.Clone.Counter)];
						CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Directories cloned or attempted to clone [$(Gqvc.Dir.v.Clone.Counter)]');
					ELSE
						TRACE Gqvc.CloneDirectory: Source directory is empty. No directories were cloned;
						CALL Gqvc.LogInformation('Gqvc.CloneDirectory: Source directory is empty. No directories were cloned');				
					END IF
				END IF
			END IF
		END IF
	ELSE
		TRACE Insufficient privilege. Directory [$(SourceDirectoryPath)] cannot be cloned; 
		CALL Gqvc.LogError('Insufficient privilege. Directory [$(SourceDirectoryPath)] cannot be cloned');   
	END IF
	
	// Cleanup
	SET Gqvc.Cleanup.v.Reserved = -1;
	CALL Gqvc.DropTable('_Gqvc.ReplicateDir');
	SET Gqvc.Cleanup.v.Reserved =;
	LET Gqvc.Dir.v.Clone.SrcDir =;
	LET Gqvc.Dir.v.Clone.TrgDir =;
	LET Gqvc.Dir.v.Clone.NoOfScannedDir =;
	LET Gqvc.Dir.v.Clone.ReproduceDir =;
	SET i=;
	SET Gqvc.Dir.v.Clone.Counter=;
	LET Gqvc.Dir.v.Clone.CloneEmpty =;
	SET CloneEmpty = ;
END SUB
// ****************************** End Sub ****************************** 
///$tab Error Management 
// Error Management - Functions for errors 


// ****************************** Start Sub ****************************** 
/* 
Create fatal error to stop execution of script 
@syntax CALL Gqvc.RaiseFatalError; 
*/ 


SUB Gqvc.RaiseFatalError 
	TRACE Fatal error raised!!; 
	CALL Gqvc.LogEvent('Fatal error raised! Script execution will stop','E'); 
	CALL Gqvc.Cleanup;
	SET ErrorMode = 2; // To force erroring out, even if Error mode is set to 0 by the user. 
	CALL FatalError; // Dummy sub to create script error 
	EXIT Script; 
END SUB 
// ****************************** End Sub ****************************** 
///$tab Log Management 
// Log Management - Functions for creating and maintaining document specific logs 

// ****************************** Start Sub ****************************** 
/* 
Creates a log file and writes event instantly. If a log file does not exists, it creates one, otherwise it appends to the log file. 

@param 1 String. Log message 
@param 2 String, Optional. Log level. Acceptable values 'E', 'I' and 'W' (case insensitive) for Error, Information and Warning respectively. Default is Information.
@param 3 String, Optional. Store path for log file, if different from current directory. By default, log is stored in same directory as the QV doc.
@syntax CALL Gqvc.LogEvent('LogMessage',['LogLevel'],['DirectoryPath']); 

Note: Do not use comma, semicolon, single or double quotes or other special characters in the log message.
*/

SET Gqvc.Log.v.NewRun = ; // Resets for each run 
SUB Gqvc.LogEvent(LogMessage,LogLevel,DirectoryPath) 

	IF LEN(LogLevel) > 0 THEN 
		LET Gqvc.Log.v.LogLevel = IF(UPPER(LEFT(LogLevel,1)) = 'W','Warning',IF(UPPER(LEFT(LogLevel,1)) = 'E','Error','Information')); 
	ELSE 
		LET Gqvc.Log.v.LogLevel = 'Information';	 
	END IF 
	
	CALL Gqvc.ResolvePath($(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)','.\')));
	
	LET Gqvc.Log.v.LogFilePath = '$(v.ResolvedDirectoryPath)\';
	LET Gqvc.Log.v.LogFileName =  TEXT(REPLACE(DOCUMENTNAME(),SUBFIELD(DOCUMENTNAME(),'.',-1),PICK(MATCH($(Gqvc.Config.v.LogMode),1,2,3),'log','log.qvd','log')));
	LET Gqvc.Log.v.LogExists = IF(FILETIME('$(Gqvc.Log.v.LogFilePath)' & '$(Gqvc.Log.v.LogFileName)')>0,-1,0);
	//IF(FILETIME(REPLACE($(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',DocumentPath())),DOCUMENTNAME(),'')&'$(Gqvc.Log.v.LogFileName)') > 0,-1,0); 
	
	IF MATCH(Gqvc.Config.v.LogMode,1,2)>0 THEN
		LET Gqvc.Log.v.FileFormat = PICK(MATCH(Gqvc.Config.v.LogMode,1,2),'(txt, utf8, embedded labels, delimiter is ' & CHR(39) & '\t' & CHR(39) &', msq)','(qvd)');
//		LET Gqvc.Log.v.Fields = PICK(MATCH(Gqvc.Config.v.LogMode,1,2),'@1 as Gqvc.LogTimestamp,@2 as Gqvc.LogLevel,@3 as Gqvc.User,@4 as Gqvc.LogMessage','Gqvc.LogTimestamp,Gqvc.LogLevel,Gqvc.User,Gqvc.LogMessage');	
		// QlikView store to txt command does not have an option to exclude headers. Hence, the workaround is to store and read header
		LET Gqvc.Log.v.Fields = 'Gqvc.LogTimestamp,Gqvc.LogLevel,Gqvc.User,Gqvc.LogMessage';	
		
		IF $(Gqvc.Macro.v.TableExists('Gqvc.Logs'))=-1 AND Gqvc.Log.v.LogExists=-1 THEN // If in memory tables doesn't exists but file exists then load in memory
			[Gqvc.Logs]:
			LOAD 
				$(Gqvc.Log.v.Fields)
			FROM [$(Gqvc.Log.v.LogFilePath)$(Gqvc.Log.v.LogFileName)] $(Gqvc.Log.v.FileFormat);			
		END IF
		
		LET Gqvc.Log.v.Concat = IF($(Gqvc.Macro.v.TableExists('Gqvc.Logs'))=0,'CONCATENATE ([Gqvc.Logs])',''); // required to identify merge to existing table or is it a new log
		
		IF Len('$(Gqvc.Log.v.NewRun)')=0 THEN
			[Gqvc.Logs]:
			$(Gqvc.Log.v.Concat)
			LOAD
				TIMESTAMP(NOW()) 			AS	Gqvc.LogTimestamp,
				'Information'				AS	Gqvc.LogLevel,
				OSUser()					AS	Gqvc.User,
				'===== New Load ====='		AS	Gqvc.LogMessage
			AUTOGENERATE 1;
			
			SET Gqvc.Log.v.NewRun = 0;
		END IF
		
		[Gqvc.Logs]:
		$(Gqvc.Log.v.Concat)
		LOAD
			TIMESTAMP(NOW()) 			AS	Gqvc.LogTimestamp,
			'$(Gqvc.Log.v.LogLevel)'	AS	Gqvc.LogLevel,
			OSUser()					AS	Gqvc.User,
			'$(LogMessage)'				AS	Gqvc.LogMessage
		AUTOGENERATE 1;
	
	// for 	
	ELSEIF Gqvc.Config.v.LogMode = 3 THEN
		 
		LET Gqvc.Log.v.SingleRedirection = CHR(62); 
		LET Gqvc.Log.v.DoubleRedirection = CHR(62)&CHR(62); 
		LET Gqvc.Log.v.Delimiter = CHR(9); // 9 = Horizontal tab 
		 
		LET Gqvc.Log.v.LogMessage = TIMESTAMP(NOW()) & '$(Gqvc.Log.v.Delimiter)' & '$(Gqvc.Log.v.LogLevel)' & '$(Gqvc.Log.v.Delimiter)' & OSUser() & '$(Gqvc.Log.v.Delimiter)' & '$(LogMessage)'; 
		LET Gqvc.Log.v.NewLoadText = TIMESTAMP(NOW()) & '$(Gqvc.Log.v.Delimiter)' & 'Information' & '$(Gqvc.Log.v.Delimiter)' & OSUser() & '$(Gqvc.Log.v.Delimiter)' & '===== New Load ====='; 
	
		LET Gqvc.Log.v.LogHeader = 'Gqvc.LogTimestamp' & '$(Gqvc.Log.v.Delimiter)' & 'Gqvc.LogLevel' & '$(Gqvc.Log.v.Delimiter)' & 'Gqvc.User' & '$(Gqvc.Log.v.Delimiter)' & 'Gqvc.LogMessage';
	
		TRACE Gqvc.LogEvent(LogMessage:[$(LogMessage)], LogLevel:[$(Gqvc.Log.v.LogLevel)]); 
		IF Gqvc.Log.v.LogExists = -1 THEN 
			IF Len('$(Gqvc.Log.v.NewRun)')=0 THEN 	// check if this is a new run.  
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";					 
				SET Gqvc.Log.v.NewRun = 0; 
			END IF 
			EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogMessage) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";		 
		ELSE 
				//EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.SingleRedirection) "$(Gqvc.Log.v.LogFileName)";
				// BELOW TWO STATEMENTS ARE TO ENSURE COMPATIBILITY ON USING "STORE" COMMAND TO GENERATE LOG
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogHeader) $(Gqvc.Log.v.SingleRedirection) "$(Gqvc.Log.v.LogFileName)";
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.NewLoadText) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)";					 
				SET Gqvc.Log.v.NewRun = 0; 
				EXECUTE CMD /C ECHO $(Gqvc.Log.v.LogMessage) $(Gqvc.Log.v.DoubleRedirection) "$(Gqvc.Log.v.LogFileName)"; 
		END IF 
	END IF
	
	// Cleanup.. 
	SET	Gqvc.Log.v.LogExists = ; 
//	 
	SET Gqvc.Log.v.SingleRedirection = ; 
	SET Gqvc.Log.v.DoubleRedirection = ; 
	SET Gqvc.Log.v.LogMessage = ; 
	SET Gqvc.Log.v.LogLevel = ; 
	SET Gqvc.Log.v.NewLoadText = ;  
	SET Gqvc.Log.v.Delimiter = ;
	SET Gqvc.Log.v.LogExists =; 
	SET Gqvc.Log.v.Fields =;
	SET Gqvc.Log.v.Concat =;
	SET Gqvc.Log.v.LogHeader =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Helper functions for easy user call to log event.

@param 1 String. Log message 
@param 2 String, Optional. Store path for log file, if different from current directory. By default, log is stored in same directory as the QV doc.
@syntax CALL Gqvc.LogError('LogMessage',['DirectoryPath']); 
*/
SUB Gqvc.LogError(LogMessage,DirectoryPath)
	LET LogMessage = $(Gqvc.Macro.v.DefaultIfEmpty('$(LogMessage)','Gqvc.LogError invoked with no log message'));
	LET DirectoryPath = $(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',''));
	CALL Gqvc.LogEvent(LogMessage,'E',DirectoryPath)
	// Cleanup
	SET LogMessage=;
	SET DirectoryPath=;
END SUB

SUB Gqvc.LogWarning(LogMessage,DirectoryPath)
	LET LogMessage = $(Gqvc.Macro.v.DefaultIfEmpty('$(LogMessage)','Gqvc.LogWarning invoked with no log message'));
	LET DirectoryPath = $(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',''));
	CALL Gqvc.LogEvent(LogMessage,'W',DirectoryPath)
	// Cleanup
	SET LogMessage=;
	SET DirectoryPath=;
END SUB

SUB Gqvc.LogInformation(LogMessage,DirectoryPath)
	LET LogMessage = $(Gqvc.Macro.v.DefaultIfEmpty('$(LogMessage)','Gqvc.LogInformation invoked with no log message'));
	LET DirectoryPath = $(Gqvc.Macro.v.DefaultIfEmpty('$(DirectoryPath)',''));
	CALL Gqvc.LogEvent(LogMessage,'I',DirectoryPath)
	// Cleanup
	SET LogMessage=;
	SET DirectoryPath=;
END SUB
// ****************************** End Sub ****************************** 
///$tab Calendar Management 
// Calendar Management - Functions for creating and maintaining generic calendars 


// ****************************** Start Sub ****************************** 
/* 
Builds a generic calendar based on an existing date field, in the data model. 


@param 1 String. Existing date field Name 
@param 2 String. New calendar table name 
@param 3 String, Optional. Calendar field name prefix 


@syntax CALL Gqvc.CreateCalendarFromField('FieldName', 'NewTableName',['FieldPrefix']); 
*/ 
SUB Gqvc.CreateCalendarFromField(FieldName,TableName,FieldPrefix)
 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 THEN 
	    TRACE Table: [$(TableName)], already exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Table: [$(TableName)], already exist. Calendar table cannot be created','E');
	ELSEIF $(Gqvc.Macro.v.FieldExists('$(FieldName)')) = -1 THEN 
	    TRACE Date Field: [$(FieldName)], does not exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Date Field: [$(FieldName)], does not exist. Calendar table cannot be created','E'); 		 
	ELSE 
		[$(TableName)]:
		NOCONCATENATE
		LOAD 
			[_Date]					AS [$(FieldName)],		// Link on Field Name 
			[_Date]					AS [%$(FieldName)],		// Link on %field name 
			YEAR(_Date)				AS [$(FieldPrefix)Year], 
			MONTH(_Date)			AS [$(FieldPrefix)Month], 
			DAY(_Date)				AS [$(FieldPrefix)Day],	 
			WEEK(_Date)				AS [$(FieldPrefix)Week], 
			WEEKDAY(_Date)			AS [$(FieldPrefix)Day Name],	 
			MONTHNAME(_Date)		AS [$(FieldPrefix)Month Year], 
			QUARTERNAME(_Date)		AS [$(FieldPrefix)Quarter Name], 
			'Q' & CEIL(MONTH(_Date)/3)		AS [$(FieldPrefix)Quarter] 
		;			 
		LOAD 
			DATE(_MinDate + IterNo()) AS _Date 
		WHILE 
			_MinDate + IterNo() <= _MaxDate + 1
		;		 
		LOAD 
			MIN(_DateField)-1 AS _MinDate, 
			MAX(_DateField) AS _MaxDate 
		;		 
		LOAD 
			FieldValue('$(FieldName)',RecNo()) AS _DateField 
		AUTOGENERATE 
			FieldValueCount('$(FieldName)');	 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Builds a generic calendar based on a start and end date values. 


@param 1 String. New calendar table name 
@param 2 Number. Calendar start date in numeric format 
@param 3 Number. Calendar end date in numeric format 
@param 4 String, Optional. Calendar field name prefix 


@syntax CALL Gqvc.CreateCalendar('NewTableName','','',['FieldPrefix']); 
*/ 


SUB Gqvc.CreateCalendar(TableName,StartDate,EndDate,FieldPrefix) 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 THEN 
	    TRACE Table: [$(TableName)], already exist. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Table: [$(TableName)], already exist. Calendar table cannot be created','E');		 
	ELSEIF $(StartDate) > $(EndDate) THEN 
		TRACE Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created;
		CALL Gqvc.LogEvent('Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created','E');	 
	ELSE	 
		[$(TableName)]:
		NOCONCATENATE
		LOAD 
			[_Date]					AS [$(FieldPrefix)Date],		// Link on Field Name 
			NUM([_Date])			AS [%$(FieldPrefix)Date],		// Link on %field name 
			YEAR(_Date)				AS [$(FieldPrefix)Year], 
			MONTH(_Date)			AS [$(FieldPrefix)Month], 
			DAY(_Date)				AS [$(FieldPrefix)Day],	 
			WEEK(_Date)				AS [$(FieldPrefix)Week], 
			WEEKDAY(_Date)			AS [$(FieldPrefix)Day Name],	 
			MONTHNAME(_Date)		AS [$(FieldPrefix)Month Year], 
			QUARTERNAME(_Date)		AS [$(FieldPrefix)Quarter Name], 
			'Q' & CEIL(MONTH(_Date)/3)		AS [$(FieldPrefix)Quarter] 
		;	  
		LOAD 
			DATE(_MinDate + IterNo()) AS _Date 
		WHILE 
			_MinDate + IterNo() <= _MaxDate 
		;		 
		LOAD 
			$(StartDate)-1 AS _MinDate, 
			$(EndDate) AS _MaxDate 
		AUTOGENERATE (1);	 
		; 
	END IF 
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Builds a generic calendar, with working days, based on a start and end date values. 

@param 1 String. New calendar table name 
@param 2 Number. Calendar start date in numeric format 
@param 3 Number. Calendar end date in numeric format 
@param 4 String, Optional. Calendar field name prefix 
@param 5 String, Optional. If present, should be comma separated numeric format dates

@syntax CALL Gqvc.CreateWorkingDayCalendar('NewTableName','StartDateNum','EndDateNum',['FieldPrefix'],['CommaSeparatedHolidayDatesNum']); 
@Ex. CALL Gqvc.CreateWorkingDayCalendar('NewTableName','43435','43465',['FieldPrefix'],['43459,43460']); 
*/ 

SUB Gqvc.CreateWorkingDayCalendar(TableName,StartDate,EndDate,FieldPrefix,HolidayList) 
	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 THEN 
	    TRACE Table: [$(TableName)], already exists. Calendar table cannot be created;
	    CALL Gqvc.LogEvent('Table: [$(TableName)], already exists. Calendar table cannot be created','E');		 
	ELSEIF $(StartDate) > $(EndDate) THEN 
		TRACE Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created;
		CALL Gqvc.LogEvent('Start date should be less than or equal to End date. Calendar Table: [$(TableName)], will not be created','E');	 
	ELSE	 
	
		LET Gqvc.Cal.v.HolidayList = IF(LEN(TRIM('$(HolidayList)'))=0,-1,'$(HolidayList)'); // Setting -1 if no holiday list if available
		LET Gqvc.Cal.v.WeekEnd =   IF(LEN(TRIM('$(DayNames)'))=0,CHR(39)&'Sat'&CHR(39)&CHR(44)&CHR(39)&'Sun'&CHR(39),CHR(39)&SUBFIELD('$(DayNames)',';',-2) &CHR(39)&CHR(44)&CHR(39)& SUBFIELD('$(DayNames)',';',-1) &CHR(39)); // set Sat & Sun as weekends if reserved variable DayNames is not available  

		[$(TableName)]:
		LOAD 
			[_Date]					AS [$(FieldPrefix)Date],		// Link on Field Name 
			NUM([_Date])			AS [%$(FieldPrefix)Date],		// Link on %field name 
			YEAR(_Date)				AS [$(FieldPrefix)Year], 
			MONTH(_Date)			AS [$(FieldPrefix)Month], 
			DAY(_Date)				AS [$(FieldPrefix)Day],	 
			WEEK(_Date)				AS [$(FieldPrefix)Week], 
			WEEKDAY(_Date)			AS [$(FieldPrefix)Day Name],	 
			MONTHNAME(_Date)		AS [$(FieldPrefix)Month Year], 
			QUARTERNAME(_Date)		AS [$(FieldPrefix)Quarter Name], 
			'Q' & CEIL(MONTH(_Date)/3)		AS [$(FieldPrefix)Quarter], 
			RANGESUM(_WorkingDayNum,PEEK(_WorkingDayNum)) AS _WorkingDayNum,
			IF(MONTHNAME(_Date)=MONTHNAME(PREVIOUS([_Date])),RANGESUM(_WorkingDayMonthNum,PEEK(_WorkingDayMonthNum)),_WorkingDayMonthNum)  AS _WorkingDayMonthNum,
			_WeekEnd,
			_IsHoliday
		;
		LOAD *, IF(_WeekEnd=1 OR _IsHoliday=1,0,1) AS _WorkingDayNum, IF(_WeekEnd=1 OR _IsHoliday=1,0,1) AS _WorkingDayMonthNum;
		LOAD 
			DATE(_MinDate + IterNo()) AS _Date, 
			IF(MIXMATCH(WEEKDAY(NUM(_MinDate + IterNo())),$(Gqvc.Cal.v.WeekEnd)),1,0) AS  _WeekEnd,
			IF(MIXMATCH(NUM(_MinDate + IterNo()),$(Gqvc.Cal.v.HolidayList)),1,0) AS _IsHoliday,
			ITERNO() AS _WorkingDayNum
		WHILE 
			_MinDate + IterNo() <= _MaxDate 
		;		 
		LOAD 
			$(StartDate)-1 AS _MinDate, 
			$(EndDate) AS _MaxDate 
			AUTOGENERATE (1)
		; 
	END IF 
	
	SET Gqvc.Cal.v.HolidayList =;
	SET Gqvc.Cal.v.WeekEnd =;

END SUB 
// ****************************** End Sub ****************************** 
///$tab DB Management 
// ****************************** Start Sub ****************************** 
SUB Gqvc.GetTimestampFromSqlDB(ReturnDBTimestamp) 
/* 
Retrieves the current timestamp from the DB.   
@syntax CALL Gqvc.GetTimestampFromSqlDB; 
*/	
	TempTimestampFromDB: 
	REPLACE LOAD *; 
	SQL SELECT GETDATE() AS CurrentTimestampFromDB; 
	 
	LET ReturnDBTimestamp = TIMESTAMP(FieldValue('CurrentTimestampFromDB',1)); 

	TRACE Gqvc.GetTimestampFromSqlDB:[$(ReturnDBTimestamp)]; 
	CALL Gqvc.DropTable('TempTimestampFromDB'); 
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
SUB Gqvc.GetTimestampFromOracleDB(ReturnDBTimestamp) 
/* 
Retrieves the current timestamp from the DB. 
@syntax CALL Gqvc.GetTimestampFromOracleDB; 
*/	 
	TempTimestampFromDB: 
	REPLACE LOAD *; 
	SQL SELECT SYSDATE "CurrentTimestampFromDB" FROM DUAL; 
	 
	LET ReturnDBTimestamp = TIMESTAMP(FieldValue('CurrentTimestampFromDB',1)); 

	TRACE Gqvc.GetTimestampFromOracleDB:[$(ReturnDBTimestamp)]; 
	CALL Gqvc.DropTable('TempTimestampFromDB'); 
END SUB 
// ****************************** End Sub ****************************** 



// ****************************** Start Sub ****************************** 
/* 
*** Supports both SQL Server integrated security and SQL authentication. ***
Retrieves the table/view information from the DB.

@param 1 String. Type of connection to be used. Supports OLEDB, ODBC, LIB. 
@param 2 String. Data base server name or library connection or ODBC connection 
@param 3 String, Optional. DB Catalog name if OLEDB is used 
@param 4 String, Optional. To force 32 bit or 64 bit connections when OLEDB connection is used. 
@param 5 String, Optional. XUserID is mandatory for ODBC connections. For OLEDB connection this should be just user id, no encryption required.
@param 6 String, Optional. XPassword is mandatory for ODBC connections. For OLEDB encrypted password is mandatory is user id is supplied as well.

@syntax CALL Gqvc.GetDataDictionaryFromSqlDB('ConnectionType','DataSource',['Catalog'],['Driver'],['XUserID'],['XPassword']); 
*/

SUB Gqvc.GetDataDictionaryFromSqlDB(ConnectionType,DataSource,Catalog,Driver,XUserID,XPassword)
	// Check arguments
	IF LEN(TRIM('$(ConnectionType)'))=0 OR MIXMATCH('$(ConnectionType)','LIB','OLEDB','ODBC')=0 THEN
	
		TRACE Gqvc.GetDataDictionaryFromSqlDB: Invalid connection. Only 'LIB','OLEDB','ODBC' are supported.; 
		CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Invalid connection. Only LIB, OLEDB, ODBC are supported.');
		//CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Error raised, exiting sub.');
		EXIT SUB;
	
	ELSEIF LEN(TRIM('$(DataSource)'))=0 AND MIXMATCH('$(ConnectionType)','OLEDB','ODBC')>0 THEN
		TRACE Gqvc.GetDataDictionaryFromSqlDB: Invalid or no data source.; 
		CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Invalid or no data source.');
		//CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Error raised, exiting sub.');
		EXIT SUB;
	
	ELSEIF LEN(TRIM('$(Catalog)'))=0 AND MIXMATCH('$(ConnectionType)','OLEDB')>0 THEN
		TRACE Gqvc.GetDataDictionaryFromSqlDB: Invalid or no catalog.; 
		CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Invalid or no catalog.');
		//CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Error raised, exiting sub.');
		EXIT SUB;
	
	ELSEIF MIXMATCH('$(ConnectionType)','ODBC') AND (LEN('$(XUserID)')=0 OR LEN('$(XPassword)')=0) THEN
		TRACE Gqvc.GetDataDictionaryFromSqlDB: ODBC connection requires encrypted user name and password.; 
		CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: ODBC connection requires encrypted user name and password.');
		EXIT SUB;
		
	END IF 

	// Build connection string
	IF MIXMATCH('$(ConnectionType)','LIB') THEN
		LET Gqvc.DB.v.SQL.ConnectString = '$(ConnectionType) CONNECT TO ' & CHR(39) & '$(DataSource)' & CHR(39);		
	ELSEIF '$(ConnectionType)'='OLEDB' THEN
		IF LEN('$(XUserID)')=0 THEN
			LET Gqvc.DB.v.SQL.ConnectString = 'OLEDB CONNECT$(Driver) TO [Provider=SQLOLEDB.1;Integrated Security=SSPI;Initial Catalog=' & CHR(39) & '$(Catalog)' & CHR(39) & ';Data Source=' & CHR(39) & '$(DataSource)' & CHR(39) & ']';
		ELSEIF (LEN('$(XUserID)') OR LEN('$(XPassword)')) THEN
			LET Gqvc.DB.v.SQL.ConnectString = 'OLEDB CONNECT$(Driver) TO [Provider=SQLOLEDB.1;User ID=' & CHR(39) & '$(XUserID)' & CHR(39) & ';Initial Catalog=' & CHR(39) & '$(Catalog)' & CHR(39) & ';Data Source=' & CHR(39) & '$(DataSource)' & CHR(39) & '] (XPassword is $(XPassword))';
		ELSE
			TRACE Gqvc.GetDataDictionaryFromSqlDB: OLEDB connection supports only integrated security or user name with encrypted password.;
			CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: OLEDB connection supports only integrated security or user name with encrypted password.');
		END IF
	ELSEIF '$(ConnectionType)'='ODBC' THEN
		LET Gqvc.DB.v.SQL.ConnectString = '$(ConnectionType) CONNECT TO ' & CHR(39) & '$(DataSource)' & CHR(39) & ' (XUserId is $(XUserID), XPassword is $(XPassword))';
				
	ENDIF	

	// Disable error mode
	SET ErrorMode = 0;
	
	// Connect to DB
	$(Gqvc.DB.v.SQL.ConnectString);
	
	IF ScriptError>0 THEN
		LET Gqvc.DB.v.SQL.ScriptError = SUBFIELD(ScriptErrorList,CHR(10),SUBSTRINGCOUNT(ScriptErrorList,CHR(10)));
		TRACE Gqvc.GetDataDictionaryFromSqlDB: Error during DB connection - $(DataSource).; 
		CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Error during DB connection - [$(DataSource)].');
		//CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Error raised, exiting sub.');
		EXIT SUB;
	
	ELSE
		TRACE Gqvc.GetDataDictionaryFromSqlDB: Connected to [$(DataSource)].; 
		CALL Gqvc.LogInformation('Gqvc.GetDataDictionaryFromSqlDB: Connected to [$(DataSource)].');	
	
	ENDIF 

	// Get DB list
	[SQLDB]:
	SELECT NAME AS [DB Name],DATABASE_ID AS [DB ID] FROM SYS.DATABASES;
	
	//DISCONNECT;
	IF NOOFROWS('SQLDB') THEN
	
		FOR i=0 to NOOFROWS('SQLDB')-1
			LET Gqvc.DB.v.SQL.CatalogName = PEEK('DB Name',i,'SQLDB');
	
			IF WILDMATCH('$(Gqvc.DB.v.SQL.CatalogName)','*')>0 THEN // For loading specific catalogs
			
				[Gqvc.SQLDataDictionary]:
				LOAD 
					*,
					DUAL([Gqvc.SQL.ColumnName],ROWNO()) AS [Gqvc.SQL.ColumnByLoadOrder]
				;
				SQL 
				SELECT  
			        '$(DataSource)' AS [Gqvc.SQL.DataSource], // Added @ 13052019
			        '$(Gqvc.DB.v.SQL.CatalogName)' AS [Gqvc.SQL.CatalogName],
			        SCH.NAME AS [Gqvc.SQL.SchemaName],
					OBJ.[NAME] AS [Gqvc.SQL.TableName],
					COL.NAME AS [Gqvc.SQL.ColumnName],
			        TYP.NAME AS [Gqvc.SQL.DataType],
			        COL.MAX_LENGTH AS [Gqvc.SQL.Size],
			        CAST(COL.PRECISION AS VARCHAR) +'/'+ CAST(COL.SCALE AS VARCHAR) AS [Gqvc.SQL.PrecisionScale],
					OBJ.TYPE_DESC AS [Gqvc.SQL.Type]					
				FROM 
					[$(Gqvc.DB.v.SQL.CatalogName)].[SYS].[ALL_OBJECTS] OBJ
					INNER JOIN [$(Gqvc.DB.v.SQL.CatalogName)].[SYS].[ALL_COLUMNS] COL	ON OBJ.OBJECT_ID = COL.OBJECT_ID
					INNER JOIN [$(Gqvc.DB.v.SQL.CatalogName)].[SYS].[TYPES] TYP			ON COL.USER_TYPE_ID = TYP.USER_TYPE_ID
					INNER JOIN [$(Gqvc.DB.v.SQL.CatalogName)].[SYS].[SCHEMAS] SCH		ON OBJ.SCHEMA_ID = SCH.SCHEMA_ID
					INNER JOIN [$(Gqvc.DB.v.SQL.CatalogName)].[SYS].[OBJECTS] SOB		ON SOB.OBJECT_ID = OBJ.OBJECT_ID
				WHERE 
					OBJ.TYPE_DESC IN ('USER_TABLE','VIEW')
					AND SOB.TYPE IN ('U','V');			
				
				IF ScriptError>0 THEN
					LET Gqvc.DB.v.SQL.ScriptError = LEFT(SUBFIELD(ScriptErrorList,CHR(10),SubStringCount(ScriptErrorList,CHR(10))),LEN(SUBFIELD(ScriptErrorList,CHR(10),SubStringCount(ScriptErrorList,CHR(10))))-1);//SUBFIELD(ScriptErrorList,CHR(10),SUBSTRINGCOUNT(ScriptErrorList,CHR(10)));
					TRACE Gqvc.GetDataDictionaryFromSqlDB: Error scanning [$(Gqvc.DB.v.SQL.CatalogName)] - $(Gqvc.DB.v.SQL.ScriptError).;
					//CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Error scanning $(Gqvc.DB.v.SQL.CatalogName) - $(Gqvc.DB.v.SQL.ScriptError).');
					CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Error scanning [$(Gqvc.DB.v.SQL.CatalogName)].');
				END IF
				
			END IF
		
		NEXT
	
	ELSE
		TRACE Gqvc.GetDataDictionaryFromSqlDB: Permission or read error [SYS.DATABASES] from [$(DataSource)];
		CALL Gqvc.LogError('Gqvc.GetDataDictionaryFromSqlDB: Permission or read error [SYS.DATABASES] from [$(DataSource)].');
	END IF
	
	CALL Gqvc.DropTable('SQLDB'); 

	SET ErrorMode = 1;
	// Clean up
	SET Gqvc.DB.v.SQL.ConnectString =;
	SET Gqvc.DB.v.SQL.ScriptError =;
	SET Gqvc.DB.v.SQL.CatalogName =;
	SET i=;
	
END SUB
// ****************************** End Sub ****************************** 
///$tab Data Extract
// ****************************** Start Sub ****************************** 
/* 
Captures data extract logs. 

@param 1 String. Name of the data table for which the stats are being recorded 
@param 2 Number. Records extracted in this run 
@param 3 Number. Records in QVD at the end of this run 
@param 4 Float. Extract start timestamp, in numeric format 
@param 5 Float. Extract end timestamp, in numeric format
@param 6 String. Extract mode

@syntax CALL Gqvc.LogTableAudit('DataTableName','RecordsThisRun','NoOfRecords','StartTime','EndTime','ExtractMode'); 
@Ex. CALL Gqvc.LogTableAudit('Customer','1234','11234','43644.999965278','43645.000648148','Delta'); 
*/ 

SUB Gqvc.LogTableAudit(TableName,RecordsThisRun,NoOfRecords,StartTime,EndTime,ExtractMode)
	[$(Gqvc.v.Extract.LogQVD)]:
    LOAD
        '$(Gqvc.v.Extract.RunID)' AS [Run ID]
        ,'$(TableName)' AS [Table Name]
        ,'$(RecordsThisRun)' AS [No of Records Extracted]
        ,'$(NoOfRecords)' AS [Total No of Records]
        ,TIMESTAMP('$(StartTime)') AS [Start Time]
        ,TIMESTAMP('$(EndTime)') AS [End Time]
        ,'$(ExtractMode)' AS [Run Mode]
    AUTOGENERATE 1;        
END SUB
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
// Initialises timestamp for upper water mark required for delta extract.
SUB Gqvc.InitialiseCutOffTS
	LET Gqvc.v.Extract.CutOffTS = NUM(NOW());
END SUB
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Initialises data extract stats. 

@param 1 String. Path where extract stats qvd is saved. Allows continuity of logs.
@param 2 String. Name of the extract log qvd 

@syntax CALL Gqvc.InitialiseStats('ExtractLogPath','ExtractLogQVD'); 
@Ex. CALL Gqvc.InitialiseStats('C:\Qlik\Extract\QVDs','Extract Stats'); 
*/ 

SUB Gqvc.InitialiseStats(ExtractLogPath,ExtractLogQVD)
	SET Gqvc.v.Extract.RunID =;
	LET Gqvc.v.Extract.StartTime =  NOW();
	LET Gqvc.v.Extract.LogQVD = '$(ExtractLogQVD)';
	IF FILESIZE('$(ExtractLogPath)$(ExtractLogQVD).qvd')>0 THEN
	    [$(ExtractLogQVD)]:
	    LOAD * FROM [$(ExtractLogPath)$(ExtractLogQVD).qvd] (QVD);
	
		LastRunID:
		LOAD MAX([Run ID]) AS LastRunID RESIDENT [$(ExtractLogQVD)];
		
	    LET Gqvc.v.Extract.RunID = PEEK('LastRunID',0,'LastRunID');
	    CALL Gqvc.DropTable('LastRunID');
	    
	END IF

	LET Gqvc.v.Extract.RunID = IF(ISNUM('$(Gqvc.v.Extract.RunID)'),'$(Gqvc.v.Extract.RunID)',0) + 1;
	TRACE Run ID: $(Gqvc.v.Extract.RunID);
	CALL Gqvc.LogInformation('Gqvc.InitialiseStats: Extract Run ID [$(Gqvc.v.Extract.RunID)]');

	CALL Gqvc.InitialiseCutOffTS;
END SUB
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Saves data extract stats to qvd. 

@param 1 String. Path to store extract stats qvd
@param 2 String. Name of the extract log qvd 

@syntax CALL Gqvc.SaveStats('ExtractLogPath','ExtractLogQVD'); 
@Ex. CALL Gqvc.SaveStats('C:\Qlik\Extract\QVDs','Extract Stats'); 
*/ 

SUB Gqvc.SaveStats(ExtractLogPath,ExtractLogQVD)
	IF NOOFROWS('$(ExtractLogQVD)') THEN
		//STORE [$(ExtractLogQVD)] INTO [$(ExtractLogPath)$(ExtractLogQVD).qvd](QVD);
		CALL Gqvc.StoreDataQvd('$(ExtractLogQVD)','$(ExtractLogPath)'); 
		TRACE Gqvc.SaveStats: Extract logs saved;
	ELSE
		TRACE Gqvc.SaveStats: No extract logs to save;
		CALL Gqvc.LogInformation('Gqvc.SaveStats: No extract logs to save');
	END IF	
	SET Gqvc.v.Extract.LogQVD = ;
	LET Gqvc.v.Extract.EndTime =  NOW();
END SUB
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
// Reset delta extract variables
SUB Gqvc.ResetExtractConfig
	SET Gqvc.v.Extract.DBTimestamp=;
	SET Gqvc.v.Stats.StartTime=;
	SET Gqvc.v.Extract.ExtractMode=;
	SET Gqvc.v.Extract.ExtractType=;
	SET Gqvc.v.Extract.DBTimestampFile=;
	SET Gqvc.v.Stats.EndTime=;
	SET Gqvc.v.Extract.NoOfRecords=;
	SET Gqvc.v.Extract.NoOfRecordsThisRun=;
	SET Gqvc.v.Extract.PK=;
	SET Gqvc.v.Extract.WhereCondition=;
	SET Gqvc.v.Load.PrimaryKey=;
	SET Gqvc.v.Load.TableName=;
	SET Gqvc.v.Load.TimeStamp=;
	SET Gqvc.v.Load.TimeStampFieldFormat=;
	SET Gqvc.v.Extract.NoOfRecordsInQvd=;
	SET Gqvc.v.Extract.TableQVD=;
	SET Gqvc.v.Load.NoOfPKRecords=;
	SET Gqvc.v.Load.NoOfDeltaRecords=;
	SET Gqvc.v.Load.NoOfCheckedRecords=;
	SET Gqvc.v.Load.DeletedRecordCheck=;
	SET Gqvc.v.Extract.DeletedRecordCheck=;
	SET Gqvc.v.Extract.EmptyTableSaved=;
	
	CALL Gqvc.DropTable('$(TableName).PK');
	CALL Gqvc.DropTable('$(TableName).Delta');
END SUB
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Ground work for extract Should be called before data pull.. 

@param 1 String. Name of the data table which is being extracted 
@param 2 String. Directory to store extracted QVD 
@param 3 String, Optional. Primary key or unique ID of the table. If omitted no unique or deleted records check is done. 
@param 4 String, Optional. Name of the timestamp field which allows to fetch delta records. If omitted, full data load is performed. 
@param 5 String, Optional. Helper argument to generate WHERE clause dynamically. E.g., 'SQL.VARCHAR' will hint the routine, DB is SQL Server and datatype of TS is varchar.
@param 6 String, Optional. If deleted records are to be checked use 'Yes'. To effectively use this argument, user must extract all primary keys of the source table in '<TableName>.PK' with only field as '<PrimaryKey>.PK'.

@syntax CALL Gqvc.InitialiseExtract('DataTableName','SavePath',['PrimaryKey'],['DateTimeField'],['DB.DataType'],['DeletedRecordCheck']); 
@Ex. CALL Gqvc.InitialiseExtract('Customer','C:\Qlik\Extract\QVDs',['CustomerUID'],['LastUpdated'],['ORA'],['Yes']);  
*/ 

SUB Gqvc.InitialiseExtract(TableName,SavePath,PrimaryKey,DateTimeField,TSFieldFormat,DeletedRecordCheck)
	IF LEN('$(DateTimeField)') THEN
		LET Gqvc.v.Extract.DBTimestampFile = '$(SavePath)' & '$(TableName)' & '.DBTimestamp';

		IF FILESIZE('$(Gqvc.v.Extract.DBTimestampFile).qvd') THEN
			[$(TableName).DBTimestamp]:
			LOAD DBTimestamp FROM [$(Gqvc.v.Extract.DBTimestampFile).qvd] (QVD);
			
			LET Gqvc.v.Extract.DBTimestamp = NUM(PEEK('DBTimestamp',0,'$(TableName).DBTimestamp'));
			LET Gqvc.v.Extract.ExtractMode = 'Delta';
			LET Gqvc.v.Extract.ExtractType = 'Delta';
			CALL Gqvc.DropTable('$(TableName).DBTimestamp');
			
			
			IF NOT ISNUM($(Gqvc.v.Extract.DBTimestamp)) OR LEN('$(Gqvc.v.Extract.DBTimestamp)')=0 THEN
	    		LET Gqvc.v.Extract.DBTimestamp = NUM(MAKEDATE(1970,1,1));
	        END IF
	
		ELSE 
			LET Gqvc.v.Extract.DBTimestamp = NUM(MAKEDATE(1970,1,1));
			LET Gqvc.v.Extract.ExtractMode = 'Delta';
			LET Gqvc.v.Extract.ExtractType = 'Full';
		END IF	
	END IF	
		
	LET Gqvc.v.Stats.StartTime = NUM(NOW());
	
	// Create where condition for SQL server or Oracle
	IF LEN('$(DateTimeField)') THEN
		IF LEN('$(TSFieldFormat)') THEN
			IF SUBFIELD('$(TSFieldFormat)','.',1)='SQL' THEN
				LET Gqvc.v.Extract.WhereCondition = 'WHERE CONVERT('& SUBFIELD('$(TSFieldFormat)','.',2) & ',[$(DateTimeField)],120) >= ' & CHR(39) & TIMESTAMP($(Gqvc.v.Extract.DBTimestamp),'YYYY-MM-DD hh:mm:ss') & CHR(39) & ' AND CONVERT('& SUBFIELD('$(TSFieldFormat)','.',2) & ',[$(DateTimeField)],120) < ' & CHR(39) & TIMESTAMP($(Gqvc.v.Extract.CutOffTS),'YYYY-MM-DD hh:mm:ss') & CHR(39);
			
			ELSEIF 	SUBFIELD('$(TSFieldFormat)','.',1)='ORA' THEN
				LET Gqvc.v.Extract.WhereCondition = 'WHERE TO_TIMESTAMP([$(DateTimeField)],' & CHR(39) & 'YYYY-MM-DD HH:MI:SS' & CHR(39) & ') >= ' & CHR(39) & TIMESTAMP($(Gqvc.v.Extract.DBTimestamp),'YYYY-MM-DD hh:mm:ss') & CHR(39) & ' AND TO_TIMESTAMP([$(DateTimeField)],' & CHR(39) & 'YYYY-MM-DD HH:MI:SS' & CHR(39) & ') < ' & CHR(39) & TIMESTAMP($(Gqvc.v.Extract.CutOffTS),'YYYY-MM-DD hh:mm:ss') & CHR(39);
			END IF
		
		ELSE
			LET Gqvc.v.Extract.WhereCondition = 'WHERE [$(DateTimeField)] >= ' & CHR(39) & TIMESTAMP($(Gqvc.v.Extract.DBTimestamp),'YYYY-MM-DD hh:mm:ss') & CHR(39) & ' AND [$(DateTimeField)] < ' & CHR(39) & TIMESTAMP($(Gqvc.v.Extract.CutOffTS),'YYYY-MM-DD hh:mm:ss') & CHR(39);
			
		END IF
	ELSE
		LET Gqvc.v.Extract.ExtractMode = 'Full';
		LET Gqvc.v.Extract.ExtractType = 'Full';
		LET Gqvc.v.Extract.WhereCondition = '';
	END IF
	
	IF LEN(TRIM('$(DeletedRecordCheck)')) AND MIXMATCH('$(DeletedRecordCheck)','Yes') THEN
		SET Gqvc.v.Extract.DeletedRecordCheck = 'Yes';
	ELSE
		SET Gqvc.v.Extract.DeletedRecordCheck = 'No';
	END IF
	
END SUB
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Finalise extract. Performs full or delta load based. Saves watermark based on data and not when the extract was run. Commits data to qvd.

@param 1 String. Name of the data table which is being extracted 
@param 2 String. Directory to store extracted QVD 
@param 3 String, Optional. Primary key or unique ID of the table. If omitted no unique or deleted records check is done. 
@param 4 String, Optional. Name of the timestamp field which allows to fetch delta records. If omitted, full data load is performed. 

@syntax CALL Gqvc.FinaliseExtract('DataTableName','SavePath',['PrimaryKey'],['DateTimeField']); 
@Ex. CALL Gqvc.FinaliseExtract('Customer','C:\Qlik\Extract\QVDs',['CustomerUID'],['LastUpdated']);  
*/

SUB Gqvc.FinaliseExtract(TableName,SavePath,PrimaryKey,DateTimeField)
	LET Gqvc.v.Extract.TableQVD = '$(SavePath)' & '$(TableName)';
	SET Gqvc.v.Extract.EmptyTableSaved = 'No';
	
	IF NOOFROWS('$(TableName)') THEN
		IF MIXMATCH('$(Gqvc.v.Extract.ExtractMode)','Delta') AND LEN('$(PrimaryKey)')>0 THEN
			LET Gqvc.v.Extract.PK = 'HASH256($(PrimaryKey)) AS [$(PrimaryKey).HID],';
			
			[$(TableName).Delta]:
			NOCONCATENATE
			LOAD $(Gqvc.v.Extract.PK) * RESIDENT [$(TableName)];	
			
			CALL Gqvc.DropTable('$(TableName)');
	
			// Store timestamp
			[$(TableName).DBTimestamp]:
			LOAD TIMESTAMP(MAX([$(DateTimeField)])) AS DBTimestamp RESIDENT [$(TableName).Delta];
			
			CALL Gqvc.StoreDropDataQvd('$(TableName).DBTimestamp', '$(SavePath)');
			//STORE [$(TableName).DBTimestamp] INTO [$(Gqvc.v.Extract.DBTimestampFile).qvd] (QVD);
			//CALL Gqvc.DropTable('$(TableName).DBTimestamp');
			
			// Get stats
			LET Gqvc.v.Extract.NoOfRecordsThisRun = NOOFROWS('$(TableName).Delta');
			
			// Merge old data
			IF FILESIZE('$(Gqvc.v.Extract.TableQVD).qvd') THEN
				LET Gqvc.v.Extract.NoOfRecordsInQvd = QVDNOOFRECORDS('$(Gqvc.v.Extract.TableQVD).qvd'); // Added to capture QVD stats
				
				CONCATENATE ([$(TableName).Delta])
				LOAD * FROM [$(Gqvc.v.Extract.TableQVD).qvd] (QVD) WHERE NOT EXISTS([$(PrimaryKey).HID]);
			END IF					
		
		ELSEIF MIXMATCH('$(Gqvc.v.Extract.ExtractMode)','Delta') AND LEN('$(PrimaryKey)')=0 THEN 
			RENAME TABLE [$(TableName)] TO [$(TableName).Delta];			
			
			[$(TableName).DBTimestamp]:
			LOAD TIMESTAMP(MAX([$(DateTimeField)])) AS DBTimestamp RESIDENT [$(TableName).Delta];
			
			CALL Gqvc.StoreDropDataQvd('$(TableName).DBTimestamp', '$(SavePath)');
			//STORE [$(TableName).DBTimestamp] INTO [$(Gqvc.v.Extract.DBTimestampFile).qvd] (QVD);
			//CALL Gqvc.DropTable('$(TableName).DBTimestamp');
			
			// Get stats
			LET Gqvc.v.Extract.NoOfRecordsThisRun = NOOFROWS('$(TableName).Delta');		
						
			IF FILESIZE('$(Gqvc.v.Extract.TableQVD).qvd') THEN
				LET Gqvc.v.Extract.NoOfRecordsInQvd = QVDNOOFRECORDS('$(Gqvc.v.Extract.TableQVD).qvd'); // Added to capture QVD stats
				
				CONCATENATE ([$(TableName).Delta])
				LOAD * FROM [$(Gqvc.v.Extract.TableQVD).qvd] (QVD);	
			
			ELSE
				LET Gqvc.v.Extract.NoOfRecordsInQvd = 0; // Added to capture QVD stats	
									
			END IF	
		
		ELSE
			RENAME TABLE [$(TableName)] TO [$(TableName).Delta];
	
			// Get stats
			LET Gqvc.v.Extract.NoOfRecordsThisRun = NOOFROWS('$(TableName).Delta');	
			LET Gqvc.v.Extract.NoOfRecordsInQvd = 0; // Added to capture QVD stats		
			
		END IF
	ELSE

		LET Gqvc.v.Extract.NoOfRecordsThisRun = 0;
		
		// Handle empty tables
		IF FILESIZE('$(Gqvc.v.Extract.TableQVD).qvd') THEN
			TRACE Gqvc.FinaliseExtract: No changed data to save [$(TableName)];
			CALL Gqvc.LogInformation('Gqvc.FinaliseExtract: No changed data to save [$(TableName)]');
			SET Gqvc.v.Extract.EmptyTableSaved = 'NA';
			CALL Gqvc.DropTable('$(TableName)');			
		ELSE
			LET Gqvc.v.Extract.NoOfRecordsInQvd = 0; // Added to capture QVD stats
		END IF

		// If table exists at this point, empty structure can be saved
		IF TABLENUMBER('$(TableName)') THEN
			TRACE Gqvc.FinaliseExtract: Saving empty structure [$(TableName)];
			CALL Gqvc.LogInformation('Gqvc.FinaliseExtract: Saving empty structure [$(TableName)]');
			
			//STORE [$(TableName)] INTO [$(Gqvc.v.Extract.TableQVD).qvd] (QVD);
			//CALL Gqvc.DropTable('$(TableName)');
			SET Gqvc.v.Extract.EmptyTableSaved = 'Yes';
			CALL Gqvc.StoreDropDataQvd('$(TableName)', '$(SavePath)');
			
		END IF

	END IF	

	IF NOOFROWS('$(TableName).Delta') AND MIXMATCH('$(Gqvc.v.Extract.EmptyTableSaved)','No') THEN
		LET Gqvc.v.Extract.NoOfRecords = NOOFROWS('$(TableName).Delta');
		LET Gqvc.v.Extract.NoOfRecordsInQvd = 0;
		
		IF LEN('$(PrimaryKey)')>0 AND TABLENUMBER('$(TableName).PK') AND NOOFROWS('$(TableName).PK') THEN
		
			LET Gqvc.v.Load.NoOfPKRecords = NOOFROWS('$(TableName).PK');
			LET Gqvc.v.Load.NoOfDeltaRecords = NOOFROWS('$(TableName).Delta');
		
			[$(TableName).Delta.DeletedCheck]:
			NOCONCATENATE
			LOAD * RESIDENT [$(TableName).Delta]
			WHERE EXISTS([$(PrimaryKey).PK],[$(PrimaryKey)]);
			
			LET Gqvc.v.Load.NoOfCheckedRecords = IF(TABLENUMBER('$(TableName).Delta.DeletedCheck'),NOOFROWS('$(TableName).Delta.DeletedCheck'),0);
			
			IF $(Gqvc.v.Load.NoOfPKRecords) = $(Gqvc.v.Load.NoOfCheckedRecords) THEN
				LET Gqvc.v.Extract.NoOfRecords = NOOFROWS('$(TableName).Delta.DeletedCheck');
				
				CALL Gqvc.StoreDropDataQvd('$(TableName).Delta.DeletedCheck', '$(SavePath)', '$(TableName)');
				//STORE [$(TableName).Delta.DeletedCheck] INTO [$(Gqvc.v.Extract.TableQVD).qvd] (QVD);
				//CALL Gqvc.DropTable('$(TableName).Delta.DeletedCheck');
				CALL Gqvc.DropTable('$(TableName).Delta');
				
				
			ELSE
				TRACE Gqvc.FinaliseExtract: Delete check failed. Records before [$(Gqvc.v.Load.NoOfDeltaRecords)], after [$(Gqvc.v.Load.NoOfCheckedRecords)], PK [$(Gqvc.v.Load.NoOfPKRecords)];
				TRACE Gqvc.FinaliseExtract: Check for valid unique key constraint. Delta data will be saved with no changes.;
				CALL Gqvc.LogWarning('Gqvc.FinaliseExtract: Delete check failed. Check for unique key constraint [$(TableName)].');
				CALL Gqvc.LogWarning('Gqvc.FinaliseExtract: Records before [$(Gqvc.v.Load.NoOfDeltaRecords)] after [$(Gqvc.v.Load.NoOfCheckedRecords)] PK [$(Gqvc.v.Load.NoOfPKRecords)]');				
				CALL Gqvc.LogWarning('Gqvc.FinaliseExtract: Delta data will be saved with no changes [$(TableName)]');
				
				CALL Gqvc.StoreDropDataQvd('$(TableName).Delta', '$(SavePath)', '$(TableName)');
				//STORE [$(TableName).Delta] INTO [$(Gqvc.v.Extract.TableQVD).qvd] (QVD);
				//CALL Gqvc.DropTable('$(TableName).Delta');
				CALL Gqvc.DropTable('$(TableName).Delta.DeletedCheck');
				
			END IF
		
		ELSE 
			CALL Gqvc.StoreDropDataQvd('$(TableName).Delta', '$(SavePath)', '$(TableName)');
			//STORE [$(TableName).Delta] INTO [$(Gqvc.v.Extract.TableQVD).qvd] (QVD);
			//CALL Gqvc.DropTable('$(TableName).Delta');
				
		END IF
	
	ELSEIF MIXMATCH('$(Gqvc.v.Extract.DeletedRecordCheck)','Yes') AND MIXMATCH('$(Gqvc.v.Extract.EmptyTableSaved)','No') THEN
		IF LEN('$(PrimaryKey)')>0 AND TABLENUMBER('$(TableName).PK') AND NOOFROWS('$(TableName).PK') THEN
		
			LET Gqvc.v.Load.NoOfPKRecords = NOOFROWS('$(TableName).PK');
			LET Gqvc.v.Load.NoOfDeltaRecords = 0;
		
			[$(TableName).Delta.DeletedCheck]:
			NOCONCATENATE
			LOAD * FROM [$(Gqvc.v.Extract.TableQVD).qvd] (QVD)
			WHERE EXISTS([$(PrimaryKey).PK],[$(PrimaryKey)]);
			
			LET Gqvc.v.Load.NoOfCheckedRecords = IF(TABLENUMBER('$(TableName).Delta.DeletedCheck'),NOOFROWS('$(TableName).Delta.DeletedCheck'),0);
			
			IF $(Gqvc.v.Load.NoOfPKRecords) = $(Gqvc.v.Load.NoOfCheckedRecords) THEN
				LET Gqvc.v.Extract.NoOfRecordsInQvd = NOOFROWS('$(TableName).Delta.DeletedCheck');
				
				CALL Gqvc.StoreDropDataQvd('$(TableName).Delta.DeletedCheck', '$(SavePath)', '$(TableName)');
				//STORE [$(TableName).Delta.DeletedCheck] INTO [$(Gqvc.v.Extract.TableQVD).qvd] (QVD);				
				//CALL Gqvc.DropTable('$(TableName).Delta.DeletedCheck');
								
			ELSE
				TRACE Gqvc.FinaliseExtract: Delete check failed. Records before [$(Gqvc.v.Load.NoOfDeltaRecords)], after [$(Gqvc.v.Load.NoOfCheckedRecords)], PK [$(Gqvc.v.Load.NoOfPKRecords)];
				TRACE Gqvc.FinaliseExtract: Check for valid unique key constraint. Delta data will not be saved [$(TableName)].;
				CALL Gqvc.LogWarning('Gqvc.FinaliseExtract: Delete check failed. Check for unique key constraint [$(TableName)].');
				CALL Gqvc.LogWarning('Gqvc.FinaliseExtract: Records before [$(Gqvc.v.Load.NoOfDeltaRecords)] after [$(Gqvc.v.Load.NoOfCheckedRecords)] PK [$(Gqvc.v.Load.NoOfPKRecords)]');				
				CALL Gqvc.LogWarning('Gqvc.FinaliseExtract: Delta data will not be saved [$(TableName)]');
				CALL Gqvc.DropTable('$(TableName).Delta.DeletedCheck');
			END IF
		
		ELSE 
			//STORE [$(TableName).Delta] INTO [$(Gqvc.v.Extract.TableQVD).qvd] (QVD);
			CALL Gqvc.StoreDropDataQvd('$(TableName).Delta', '$(SavePath)', '$(TableName)');
			//CALL Gqvc.DropTable('$(TableName).Delta');	
		END IF
	
	ELSEIF MIXMATCH('$(Gqvc.v.Extract.EmptyTableSaved)','NA') AND FILESIZE('$(Gqvc.v.Extract.TableQVD).qvd') THEN
		LET Gqvc.v.Extract.NoOfRecords = 0;
		LET Gqvc.v.Extract.NoOfRecordsInQvd = QVDNOOFRECORDS('$(Gqvc.v.Extract.TableQVD).qvd');
	
	ELSE
		LET Gqvc.v.Extract.NoOfRecords = 0;
		LET Gqvc.v.Extract.NoOfRecordsInQvd = 0;
		
	END IF
	
	LET Gqvc.v.Extract.NoOfRecords = RANGEMAX($(Gqvc.v.Extract.NoOfRecordsInQvd),$(Gqvc.v.Extract.NoOfRecords)); // To store stats of QVD when no records are fetched during the run.
	
	LET Gqvc.v.Stats.EndTime = NUM(NOW());
	CALL Gqvc.LogTableAudit('$(TableName)','$(Gqvc.v.Extract.NoOfRecordsThisRun)','$(Gqvc.v.Extract.NoOfRecords)','$(Gqvc.v.Stats.StartTime)','$(Gqvc.v.Stats.EndTime)','$(Gqvc.v.Extract.ExtractType)');
	CALL Gqvc.ResetExtractConfig;
END SUB
// ****************************** End Sub ****************************** 
///$tab HTML Tags
/* 
	Character code set for HTML symbols.
	This is an extensive list, albiet not complete, should allow conversion of most latin characters. 
*/

Gqvc.HTML.Symbol:
LOAD *;
LOAD * INLINE [
    Gqvc.HTML.Decimal, Gqvc.HTML.Character, Gqvc.HTML.Symbol, Gqvc.HTML.Description
    &#160;, &nbsp;, , no-break space
    &#161;, &iexcl;, ¡, inverted exclamation mark
    &#162;, &cent;, ¢, cent sign
    &#163;, &pound;, £, pound sign
    &#164;, &curren;, ¤, currency sign
    &#165;, &yen;, ¥, yen sign = yuan sign
    &#166;, &brvbar;, ¦, broken bar = brolen vertical bar
    &#167;, &sect;, §, section sign
    &#168;, &uml;, ¨, diaeresis = spacing diaeresis
    &#169;, &copy;, ©, copyright sign
    &#170;, &ordf;, ª, feminine ordinal indicator
    &#171;, &laquo;, «, left-pointing double angle quotation mark = left pointing guillemet
    &#172;, &not;, ¬, not sign = discretionary hyphen
    &#173;, &shy;, ­, soft hyphen = discretionary hyphen
    &#174;, &reg;, ®, registered sign = registered trade mark sign
    &#175;, &macr;, ¯, macron = spacing macron = overline = APL overbar
    &#176;, &deg;, °, degree sign
    &#177;, &plusmn;, ±, plus-minus sign = plus-or-minus sign
    &#178;, &sup2;, ², superscript two = superscript digit two = squared
    &#179;, &sup3;, ³, superscript three = superscript digit three = cubed
    &#180;, &acute;, "´", acute accent = spacing acute
    &#181;, &micro;, µ, micro sign
    &#182;, &para;, ¶, pilcrow sign = paragraph sign
    &#183;, &middot;, ·, middle dot = Georgian comma = Greek middle dot
    &#184;, &ccedil;, ¸, cedilla = spacing cedilla
    &#185;, &sup1;, ¹, superscript one = superscript digit one
    &#186;, &ordm;, º, masculine ordinal indicator
    &#187;, &raquo;, », right-pointing double angle quotation mark = right pointing guillemet
    &#188;, &frac14;, ¼, vulgar fraction one quarter = fraction one quarter
    &#189;, &frac12;, ½, vulgar fraction one half = fraction one half
    &#190;, &frac34;, ¾, vulgar fraction three quarters = fraction three quarters
    &#191;, &iquest;, ¿, inverted question mark = turned question mark
    &#192;, &Agrave;, À, latin capital letter A with grave = latin capital letter A grave
    &#193;, &Aacute;, Á, latin capital letter A with acute
    &#194;, &Acirc;, Â, latin capital letter A with circumflex
    &#195;, &Atilde;, Ã, latin capital letter A with tilde
    &#196;, &Auml;, Ä, latin capital letter A with diaeresis
    &#197;, &Aring;, Å, latin capital letter A with ring above = latin capital letter A ring
    &#198;, &AElig;, Æ, latin capital letter AE = latin capital ligature AE
    &#199;, &Ccedil;, Ç, latin capital letter C with cedilla
    &#200;, &Egrave;, È, latin capital letter E with grave
    &#201;, &Eacute;, É, latin capital letter E with acute
    &#202;, &Ecirc;, Ê, latin capital letter E with circumflex
    &#203;, &Euml;, Ë, latin capital letter E with diaeresis
    &#204;, &Igrave;, Ì, latin capital letter I with grave
    &#205;, &Iacute;, Í, latin capital letter I with acute
    &#206;, &Icirc;, Î, latin capital letter I with circumflex
    &#207;, &Iuml;, Ï, latin capital letter I with diaeresis
    &#208;, &ETH;, Ð, latin capital letter ETH
    &#209;, &Ntilde;, Ñ, latin capital letter N with tilde
    &#210;, &Ograve;, Ò, latin capital letter O with grave
    &#211;, &Oacute;, Ó, latin capital letter O with acute
    &#212;, &Ocirc;, Ô, latin capital letter O with circumflex
    &#213;, &Otilde;, Õ, latin capital letter O with tilde
    &#214;, &Ouml;, Ö, latin capital letter O with diaeresis
    &#215;, &times;, ×, multiplication sign
    &#216;, &Oslash;, Ø, latin capital letter O with stroke = latin capital letter O slash
    &#217;, &Ugrave;, Ù, latin capital letter U with grave
    &#218;, &Uacute;, Ú, latin capital letter U with acute
    &#219;, &Ucirc;, Û, latin capital letter U with circumflex
    &#220;, &Uuml;, Ü, latin capital letter U with diaeresis
    &#221;, &Yacute;, Ý, latin capital letter Y with acute
    &#222;, &THORN;, Þ, latin capital letter THORN
    &#223;, &szlig;, ß, latin small letter sharp s = ess-zed
    &#224;, &agrave;, à, latin small letter a with grave = latin small letter a grave
    &#225;, &aacute;, á, latin small letter a with acute
    &#226;, &acirc;, â, latin small letter a with circumflex
    &#227;, &atilde;, ã, latin small letter a with tilde
    &#228;, &auml;, ä, latin small letter a with diaeresis
    &#229;, &aring;, å, latin small letter a with ring above = latin small letter a ring
    &#230;, &aelig;, æ, latin small letter ae = latin small ligature ae
    &#231;, &ccedil;, ç, latin small letter c with cedilla
    &#232;, &egrave;, è, latin small letter e with grave
    &#233;, &eacute;, é, latin small letter e with acute
    &#234;, &ecirc;, ê, latin small letter e with circumflex
    &#235;, &euml;, ë, latin small letter e with diaeresis
    &#236;, &igrave;, ì, latin small letter i with grave
    &#237;, &iacute;, í, latin small letter i with acute
    &#238;, &icirc;, î, latin small letter i with circumflex
    &#239;, &iuml;, ï, latin small letter i with diaeresis
    &#240;, &eth;, ð, latin small letter eth
    &#241;, &ntilde;, ñ, latin small letter n with tilde
    &#242;, &ograve;, ò, latin small letter o with grave
    &#243;, &oacute;, ó, latin small letter o with acute
    &#244;, &ocirc;, ô, latin small letter o with circumflex
    &#245;, &otilde;, õ, latin small letter o with tilde
    &#246;, &ouml;, ö, latin small letter o with diaeresis
    &#247;, &divide;, ÷, division sign
    &#248;, &oslash;, ø, latin small letter o with stroke = latin small letter o slash
    &#249;, &ugrave;, ù, latin small letter u with grave
    &#250;, &uacute;, ú, latin small letter u with acute
    &#251;, &ucirc;, û, latin small letter u with circumflex
    &#252;, &uuml;, ü, latin small letter u with diaeresis
    &#253;, &yacute;, ý, latin small letter y with acute
    &#254;, &thorn;, þ, latin small letter thorn with
    &#255;, &yuml;, ÿ, latin small letter y with diaeresis
    &#402;, &fnof;, ƒ, latin small f with hook = function = florin
    &#913;, &Alpha;, Α, greek capital letter alpha
    &#914;, &Beta;, Β, greek capital letter beta
    &#915;, &Gamma;, Γ, greek capital letter gamma
    &#916;, &Delta;, Δ, greek capital letter delta
    &#917;, &Epsilon;, Ε, greek capital letter epsilon
    &#918;, &Zeta;, Ζ, greek capital letter zeta
    &#919;, &Eta;, Η, greek capital letter eta
    &#920;, &Theta;, Θ, greek capital letter theta
    &#921;, &Iota;, Ι, greek capital letter iota
    &#922;, &Kappa;, Κ, greek capital letter kappa
    &#923;, &Lambda;, Λ, greek capital letter lambda
    &#924;, &Mu;, Μ, greek capital letter mu
    &#925;, &Nu;, Ν, greek capital letter nu
    &#926;, &Xi;, Ξ, greek capital letter xi
    &#927;, &Omicron;, Ο, greek capital letter omicron
    &#928;, &Pi;, Π, greek capital letter pi
    &#929;, &Rho;, Ρ, greek capital letter rho
    &#931;, &Sigma;, Σ, greek capital letter sigma
    &#932;, &Tau;, Τ, greek capital letter tau
    &#933;, &Upsilon;, Υ, greek capital letter upsilon
    &#934;, &Phi;, Φ, greek capital letter phi
    &#935;, &Chi;, Χ, greek capital letter chi
    &#936;, &Psi;, Ψ, greek capital letter psi
    &#937;, &Omega;, Ω, greek capital letter omega
    &#945;, &alpha;, α, greek small letter alpha
    &#946;, &beta;, β, greek small letter beta
    &#947;, &gamma;, γ, greek small letter gamma
    &#948;, &delta;, δ, greek small letter delta
    &#949;, &epsilon;, ε, greek small letter epsilon
    &#950;, &zeta;, ζ, greek small letter zeta
    &#951;, &eta;, η, greek small letter eta
    &#952;, &theta;, θ, greek small letter theta
    &#953;, &iota;, ι, greek small letter iota
    &#954;, &kappa;, κ, greek small letter kappa
    &#955;, &lambda;, λ, greek small letter lambda
    &#956;, &mu;, μ, greek small letter mu
    &#957;, &nu;, ν, greek small letter nu
    &#958;, &xi;, ξ, greek small letter xi
    &#959;, &omicron;, ο, greek small letter omicron
    &#960;, &pi;, π, greek small letter pi
    &#961;, &rho;, ρ, greek small letter rho
    &#962;, &sigmaf;, ς, greek small letter final sigma
    &#963;, &sigma;, σ, greek small letter sigma
    &#964;, &tau;, τ, greek small letter tau
    &#965;, &upsilon;, υ, greek small letter upsilon
    &#966;, &phi;, φ, greek small letter phi
    &#967;, &chi;, χ, greek small letter chi
    &#968;, &psi;, ψ, greek small letter psi
    &#969;, &omega;, ω, greek small letter omega
    &#977;, &thetasym;, ϑ, greek small letter theta symbol
    &#978;, &upsih;, ϒ, greek upsilon with hook symbol
    &#982;, &piv;, ϖ, greek pi symbol
    &#8226;, &bull;, •, bullet = black small circle
    &#8230;, &hellip;, …, horizontal ellipsis = three dot leader
    &#8242;, &prime;, ′, prime = minutes = feet
    &#8243;, &Prime;, ″, double prime = seconds = inches
    &#8254;, &oline;, ‾, overline = spacing overscore
    &#8260;, &frasl;, ⁄, fraction slash
    &#8472;, &weierp;, ℘, script capital P = power set = Weierstrass p
    &#8465;, &image;, ℑ, blackletter capital I = imaginary part
    &#8476;, &real;, ℜ, blackletter capital R = real part symbol
    &#8482;, &trade;, ™, trade mark sign
    &#8501;, &alefsym;, ℵ, alef symbol = first transfinite cardinal
    &#8592;, &larr;, ←, leftwards arrow
    &#8593;, &uarr;, ↑, upwards arrow
    &#8594;, &rarr;, →, rightwards arrow
    &#8595;, &darr;, ↓, downwards arrow
    &#8596;, &harr;, ↔, left right arrow
    &#8629;, &crarr;, ↵, downwards arrow with corner leftwards = carriage return
    &#8656;, &lArr;, ⇐, leftwards double arrow
    &#8657;, &uArr;, ⇑, upwards double arrow
    &#8658;, &rArr;, ⇒, rightwards double arrow
    &#8659;, &dArr;, ⇓, downwards double arrow
    &#8660;, &hArr;, ⇔, left right double arrow
    &#8704;, &forall;, ∀, for all
    &#8706;, &part;, ∂, partial differential
    &#8707;, &exist;, ∃, there exists
    &#8709;, &empty;, ∅, empty set = null set = diameter
    &#8711;, &nabla;, ∇, nabla = backward difference
    &#8712;, &isin;, ∈, element of
    &#8713;, &notin;, ∉, not an element of
    &#8715;, &ni;, ∋, contains as member
    &#8719;, &prod;, ∏, n-ary product = product sign
    &#8721;, &sum;, ∑, n-ary sumation
    &#8722;, &minus;, −, minus sign
    &#8727;, &lowast;, ∗, asterisk operator
    &#8730;, &radic;, √, square root = radical sign
    &#8733;, &prop;, ∝, proportional to
    &#8734;, &infin;, ∞, infinity
    &#8736;, &ang;, ∠, angle
    &#8743;, &and;, ∧, logical and = wedge
    &#8744;, &or;, ∨, logical or = vee
    &#8745;, &cap;, ∩, intersection = cap
    &#8746;, &cup;, ∪, union = cup
    &#8747;, &int;, ∫, integral
    &#8756;, &there4;, ∴, therefore
    &#8764;, &sim;, ∼, tilde operator = varies with = similar to
    &#8773;, &cong;, ≅, approximately equal to
    &#8776;, &asymp;, ≈, almost equal to = asymptotic to
    &#8800;, &ne;, ≠, not equal to
    &#8801;, &equiv;, ≡, identical to
    &#8804;, &le;, ≤, less-than or equal to
    &#8805;, &ge;, ≥, greater-than or equal to
    &#8834;, &sub;, ⊂, subset of
    &#8835;, &sup;, ⊃, superset of
    &#8836;, &nsub;, ⊄, not a subset of
    &#8838;, &sube;, ⊆, subset of or equal to
    &#8839;, &supe;, ⊇, superset of or equal to
    &#8853;, &oplus;, ⊕, circled plus = direct sum
    &#8855;, &otimes;, ⊗, circled times = vector product
    &#8869;, &perp;, ⊥, up tack = orthogonal to = perpendicular
    &#8901;, &sdot;, ⋅, dot operator
    &#8968;, &lceil;, ⌈, left ceiling = apl upstile
    &#8969;, &rceil;, ⌉, right ceiling
    &#8970;, &lfloor;, ⌊, left floor = apl downstile
    &#8971;, &rfloor;, ⌋, right floor
    &#9001;, &lang;, 〈, left-pointing angle bracket = bra
    &#9002;, &rang;, 〉, right-pointing angle bracket = ket
    &#9674;, &loz;, ◊, lozenge
    &#9824;, &spades;, ♠, black spade suit
    &#9827;, &clubs;, ♣, black club suit = shamrock
    &#9829;, &hearts;, ♥, black heart suit = valentine
    &#9830;, &diams;, ♦, black diamond suit
    &#34;, &quot;, '"', quotation mark = APL quote
    &#38;, &amp;, &, ampersand
    &#60;, &lt;, <, less-than sign
    &#62;, &gt;, >, greater-than sign
    &#338;, &OElig;, Œ, latin capital ligature OE
    &#339;, &oelig;, œ, latin small ligature oe
    &#352;, &Scaron;, Š, latin capital letter S with caron
    &#353;, &scaron;, š, latin small letter s with caron
    &#376;, &Yuml;, Ÿ, latin capital letter Y with diaeresis
    &#710;, &circ;, ˆ, modifier letter circumflex accent
    &#732;, &tilde;, ˜, small tilde
    &#8194;, &ensp;,  , en space
    &#8195;, &emsp;,  , em space
    &#8201;, &thinsp;,  , thin space
    &#8204;, &zwnj;, ‌, zero width non-joiner
    &#8205;, &zwj;, ‍, zero width joiner
    &#8206;, &lrm;, ‎, left-to-right mark
    &#8207;, &rlm;, ‏, right-to-left mark
    &#8211;, &ndash;, –, en dash
    &#8212;, &mdash;, —, em dash
    &#8216;, &lsquo;, ‘, left single quotation mark
    &#8217;, &rsquo;, ’, right single quotation mark
    &#8218;, &sbquo;, ‚, single low-9 quotation mark
    &#8220;, &ldquo;, “, left double quotation mark
    &#8221;, &rdquo;, ”, right double quotation mark
    &#8222;, &bdquo;, „, double low-9 quotation mark
    &#8224;, &dagger;, †, dagger
    &#8225;, &Dagger;, ‡, double dagger
    &#8240;, &permil;, ‰, per mille sign
    &#8249;, &lsaquo;, ‹, single left-pointing angle quotation mark
    &#8250;, &rsaquo;, ›, single right-pointing angle quotation mark
    &#8364;, &euro;, €, euro sign
];

// ****************************** Start Sub ****************************** 
/* 
*** Creates a HMTL tag mapping table based on name of the table and field that needs cleansing.
Use this routine to remove HMTL tags from source data.
@param 1 String.  
@param 2 String. 
@param 3 String, Optional. 
@param 4 String, Optional. 

@syntax CALL Gqvc.CleanHTMLTag('ConnectionType','DataSource',['Catalog'],['Driver']); 
*/
//SUB Gqvc.HTML.CleanHTMLTag(FieldName,TableName,DirectoryPath)
	
//	IF $(Gqvc.Macro.v.TableExists('$(TableName)')) <> -1 AND $(Gqvc.Macro.v.FieldExists('$(FieldName)')) <> -1 THEN 
//		LET Gqvc.HTML.v.MappingTable = 'Gqvc.HMTL.Map.' & $(Gqvc.Macro.v.CleanString('$(TableName)')) & '.' & $(Gqvc.Macro.v.CleanString('$(FieldName)')); 
//	
//	
//	END IF
//	IF  <> -1 THEN 
//	    TRACE Table: [$(TableName)], already exists. Mapping table cannot be created;
//	    CALL Gqvc.LogError('Gqvc.LogEvent: Mapping table [$(TableName)], already exists. Mapping table cannot be created');		 
//
//	ELSE	 
//	
//	END IF
//END SUB
// ****************************** End Sub ****************************** 
///$tab Cleanup 
// Cleanup Gqvc created temporary variables, fields and tables 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.Cleanup; 
*/ 

SUB Gqvc.Cleanup
	TRACE ****************************** Cleanup started ******************************;
	CALL Gqvc.CleanupLogs
	CALL Gqvc.CleanupReservedTables 
	CALL Gqvc.CleanupVariables 
	IF MATCH($(Gqvc.Config.v.CleanupVariables),1,2) > 0 THEN // Delete macros if config allows
		CALL Gqvc.CleanupMacros
	END IF
	IF MATCH($(Gqvc.Config.v.CleanupVariables),2) > 0 THEN // Delete configuration variables if config allows
		CALL Gqvc.CleanupReservedVariables
	END IF	 
	TRACE ****************************** Cleanup finished ******************************;
END SUB 
// ****************************** End Sub ****************************** 


// ****************************** Start Sub ****************************** 
/* 
Cleanup Variables 
@syntax CALL Gqvc.CleanupVariables; 
*/ 
SUB Gqvc.CleanupVariables 
	// Directory 
	LET v.ResolvedDirectoryPath =; 
	LET v.NodeCount =; 
	LET v.FixedPath =; 
	LET v.ResolvedRelativePath =; 

	// Log	 
	LET Gqvc.Log.v.NewRun =; 
	 
	// DB 
	LET ReturnDBTimestamp =;
	
	// Recursive routines
	LET Gqvc.Rcrv.v.DirectoryPath =;
	LET Gqvc.Rcrv.v.Mask =;
	LET Gqvc.Rcrv.v.IncludeSubFolder =;
	LET Gqvc.Rcrv.v.LoopBackParm =;
	LET Gqvc.Rcrv.v.ParmOverride =;
	LET Gqvc.Rcrv.v.LoopBack =;
	LET Gqvc.Rcrv.v.Callback =;
	LET Gqvc.Rcrv.v.Counter =;
	
	LET DirectoryPath =;
	LET IncludeSubfolder =;
	LET LoopBack =;
	LET LoopBackParm =;
	LET ParmOverride =;
	LET Dir =;
	LET FileExtension =;
	LET File =;
	
	// Clone dir
	LET Gqvc.Dir.v.Clone.SrcDir =;
	LET Gqvc.Dir.v.Clone.TrgDir =;
	LET Gqvc.Dir.v.Clone.NoOfScannedDir =;
	LET Gqvc.Dir.v.Clone.ReproduceDir =;
	SET i=;
	SET Gqvc.Dir.v.Clone.Counter=;
	
	// GetDataDictionaryFromSqlDB
	SET ConnectionType =;
	SET DataSource =;
	SET Catalog =;
	SET Driver =;
	SET XUserID =;
	SET XPassword =;
	
	// Data extract
	SET Gqvc.v.Extract.LogQVD =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupMacros; 
*/ 

SUB Gqvc.CleanupMacros 
	LET Gqvc.Macro.v.CreateBitString =; 
	LET Gqvc.Macro.v.CreateRandomName =; 
	LET Gqvc.Macro.v.DefaultIfEmpty =; 
	LET Gqvc.Macro.v.FieldExists =; 	 
	LET Gqvc.Macro.v.FileExists =;
	LET Gqvc.Macro.v.IsReserved =;
	LET Gqvc.Macro.v.TableExists =;
	LET Gqvc.Macro.v.GetSelectedField =;
	LET Gqvc.Macro.v.SelectedField =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupReservedVariables; 
*/ 

SUB Gqvc.CleanupReservedVariables 
	// Gqvc Configuration
	SET Gqvc.Config.v.SystemAccessMode =;
	SET Gqvc.Config.v.LogMode =;
	SET Gqvc.Config.v.CleanupVariables =;
	SET Gqvc.Config.v.CleanupTables =;
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup 
@syntax CALL Gqvc.CleanupReservedTables; 
*/ 

SUB Gqvc.CleanupReservedTables 	
	LET Gqvc.Cleanup.v.Mode = 'Mode'&$(Gqvc.Config.v.CleanupTables);
	
	[Gqvc.CleanupReservedTables]:
	LOAD CleanupTables RESIDENT	Gqvc.CleanupTables WHERE $(Gqvc.Cleanup.v.Mode) = 1;
	
	SET Gqvc.Cleanup.v.Reserved = 1; // Enable deletion of reserved tables
	IF NOOFROWS('Gqvc.CleanupReservedTables') > 0 THEN
		FOR i=0 TO NOOFROWS('Gqvc.CleanupReservedTables') - 1
			LET Gqvc.Cleanup.v.TableName = PEEK('CleanupTables',$(i),'Gqvc.CleanupReservedTables');
			CALL Gqvc.DropTable('$(Gqvc.Cleanup.v.TableName)');
		NEXT
	END IF
	
	// Cleanup
	CALL Gqvc.DropTable('Gqvc.CleanupTables');
	CALL Gqvc.DropTable('Gqvc.CleanupReservedTables');
	
	SET i=;
	SET Gqvc.Cleanup.v.Reserved =;
	SET Gqvc.Cleanup.v.Mode =;
	SET Gqvc.Cleanup.v.TableName =;	
END SUB 
// ****************************** End Sub ****************************** 

// ****************************** Start Sub ****************************** 
/* 
Cleanup Logs 
@syntax CALL Gqvc.CleanupLogs; 
*/ 
SUB Gqvc.CleanupLogs
	IF $(Gqvc.Macro.v.TableExists('Gqvc.Logs')) = 0 THEN 
		STORE [Gqvc.Logs] INTO [$(Gqvc.Log.v.LogFilePath)$(Gqvc.Log.v.LogFileName)] $(Gqvc.Log.v.FileFormat);
		DROP TABLE [Gqvc.Logs];
	END IF
	
	// Cleanup
	SET Gqvc.Log.v.LogFileName = ;
	SET Gqvc.Log.v.LogFilePath = ;
	SET Gqvc.Log.v.FileFormat = ;
	
END SUB
// ****************************** End Sub ****************************** 
